# Personas, Competitor Discovery & Keyword Persistence — Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Auto-discover competitors (via Perplexity Sonar), generate audience personas + keywords (via Anthropic Haiku) after crawl completion, persist all results, and provide CRUD + benchmarking UI.

**Architecture:** After a crawl completes, a discovery pipeline extracts site signals → calls Perplexity for competitor discovery → calls Anthropic for persona/keyword generation → saves everything to Neon PG. Users manage personas/competitors/keywords through new dashboard tabs and see benchmarks in a comparison table. Avatars use DiceBear (free) with optional Workers AI generation (Pro+).

**Tech Stack:** Hono API routes, Drizzle ORM (pgTable/pgEnum), Perplexity Sonar API, Anthropic Haiku, DiceBear avatars, Cloudflare Workers AI (Flux Schnell), Vitest, Next.js (App Router + dynamic tabs)

**Design doc:** `docs/plans/2026-02-18-personas-competitors-keywords-design.md`

---

## Task 1: Add new enums and tables to schema

**Files:**

- Modify: `packages/db/src/schema.ts`

**Step 1: Add the new enums after the existing enums block (~line 75)**

```ts
export const funnelStageEnum = pgEnum("funnel_stage", [
  "education",
  "comparison",
  "purchase",
]);

export const keywordSourceEnum = pgEnum("keyword_source", [
  "auto_discovered",
  "user_added",
  "perplexity",
]);
```

**Step 2: Add `source` column to existing `competitors` table (~line 633)**

Find the `competitors` table definition and add a `source` column after `domain`:

```ts
source: text("source").notNull().default("user_added"),
```

**Step 3: Add `personas` table after the `competitors` table**

```ts
export const personas = pgTable(
  "personas",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    projectId: uuid("project_id")
      .notNull()
      .references(() => projects.id, { onDelete: "cascade" }),
    name: text("name").notNull(),
    role: text("role").notNull(),
    jobToBeDone: text("job_to_be_done"),
    constraints: text("constraints"),
    successMetrics: text("success_metrics"),
    decisionCriteria: text("decision_criteria"),
    vocabulary: text("vocabulary").array().default([]),
    sampleQueries: text("sample_queries").array().default([]),
    funnelStage: funnelStageEnum("funnel_stage").notNull().default("education"),
    avatarUrl: text("avatar_url"),
    isAutoGenerated: boolean("is_auto_generated").notNull().default(true),
    createdAt: timestamp("created_at").notNull().defaultNow(),
  },
  (t) => [index("idx_personas_project").on(t.projectId)],
);
```

**Step 4: Add `savedKeywords` table after `personas`**

```ts
export const savedKeywords = pgTable(
  "saved_keywords",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    projectId: uuid("project_id")
      .notNull()
      .references(() => projects.id, { onDelete: "cascade" }),
    keyword: text("keyword").notNull(),
    source: keywordSourceEnum("source").notNull().default("user_added"),
    relevanceScore: real("relevance_score"),
    funnelStage: funnelStageEnum("funnel_stage"),
    personaId: uuid("persona_id").references(() => personas.id, {
      onDelete: "set null",
    }),
    createdAt: timestamp("created_at").notNull().defaultNow(),
  },
  (t) => [
    index("idx_saved_keywords_project").on(t.projectId),
    index("idx_saved_keywords_persona").on(t.personaId),
  ],
);
```

**Step 5: Push schema to dev database**

Run: `cd packages/db && npx drizzle-kit push`
Expected: Tables `personas`, `saved_keywords` created, `competitors` gets new `source` column.

**Step 6: Verify typecheck**

Run: `pnpm --filter db typecheck`
Expected: PASS

**Step 7: Commit**

```bash
git add packages/db/src/schema.ts
git commit -m "feat(db): add personas, saved_keywords tables and funnel_stage enum"
```

---

## Task 2: Add query helpers for personas and keywords

**Files:**

- Create: `packages/db/src/queries/personas.ts`
- Create: `packages/db/src/queries/saved-keywords.ts`
- Modify: `packages/db/src/index.ts` (add exports)

**Step 1: Create `packages/db/src/queries/personas.ts`**

Follow the exact pattern from `packages/db/src/queries/competitors.ts`:

```ts
import { eq, desc, and } from "drizzle-orm";
import type { Database } from "../client";
import { personas } from "../schema";

export function personaQueries(db: Database) {
  return {
    async getById(id: string) {
      return db.query.personas.findFirst({
        where: eq(personas.id, id),
      });
    },

    async listByProject(projectId: string) {
      return db.query.personas.findMany({
        where: eq(personas.projectId, projectId),
        orderBy: [desc(personas.createdAt)],
      });
    },

    async countByProject(projectId: string) {
      const results = await db.query.personas.findMany({
        where: eq(personas.projectId, projectId),
        columns: { id: true },
      });
      return results.length;
    },

    async create(data: {
      projectId: string;
      name: string;
      role: string;
      jobToBeDone?: string;
      constraints?: string;
      successMetrics?: string;
      decisionCriteria?: string;
      vocabulary?: string[];
      sampleQueries?: string[];
      funnelStage?: "education" | "comparison" | "purchase";
      avatarUrl?: string;
      isAutoGenerated?: boolean;
    }) {
      const [persona] = await db.insert(personas).values(data).returning();
      return persona;
    },

    async update(
      id: string,
      data: Partial<{
        name: string;
        role: string;
        jobToBeDone: string;
        constraints: string;
        successMetrics: string;
        decisionCriteria: string;
        vocabulary: string[];
        sampleQueries: string[];
        funnelStage: "education" | "comparison" | "purchase";
        avatarUrl: string;
      }>,
    ) {
      const [updated] = await db
        .update(personas)
        .set(data)
        .where(eq(personas.id, id))
        .returning();
      return updated;
    },

    async remove(id: string) {
      const [deleted] = await db
        .delete(personas)
        .where(eq(personas.id, id))
        .returning();
      return deleted;
    },
  };
}
```

**Step 2: Create `packages/db/src/queries/saved-keywords.ts`**

```ts
import { eq, desc } from "drizzle-orm";
import type { Database } from "../client";
import { savedKeywords } from "../schema";

export function savedKeywordQueries(db: Database) {
  return {
    async listByProject(projectId: string) {
      return db.query.savedKeywords.findMany({
        where: eq(savedKeywords.projectId, projectId),
        orderBy: [desc(savedKeywords.createdAt)],
      });
    },

    async create(data: {
      projectId: string;
      keyword: string;
      source?: "auto_discovered" | "user_added" | "perplexity";
      relevanceScore?: number;
      funnelStage?: "education" | "comparison" | "purchase";
      personaId?: string;
    }) {
      const [kw] = await db.insert(savedKeywords).values(data).returning();
      return kw;
    },

    async createMany(
      rows: Array<{
        projectId: string;
        keyword: string;
        source?: "auto_discovered" | "user_added" | "perplexity";
        relevanceScore?: number;
        funnelStage?: "education" | "comparison" | "purchase";
        personaId?: string;
      }>,
    ) {
      if (rows.length === 0) return [];
      return db.insert(savedKeywords).values(rows).returning();
    },

    async remove(id: string) {
      const [deleted] = await db
        .delete(savedKeywords)
        .where(eq(savedKeywords.id, id))
        .returning();
      return deleted;
    },

    async countByProject(projectId: string) {
      const results = await db.query.savedKeywords.findMany({
        where: eq(savedKeywords.projectId, projectId),
        columns: { id: true },
      });
      return results.length;
    },
  };
}
```

**Step 3: Export from `packages/db/src/index.ts`**

Add these export lines alongside existing query exports:

```ts
export { personaQueries } from "./queries/personas";
export { savedKeywordQueries } from "./queries/saved-keywords";
```

Also export the new schema tables if not auto-exported:

```ts
export {
  personas,
  savedKeywords,
  funnelStageEnum,
  keywordSourceEnum,
} from "./schema";
```

**Step 4: Add tables to drizzle relations (if applicable)**

Check `packages/db/src/relations.ts` (if it exists) and add `personas` and `savedKeywords` to the relations config so `db.query.personas` works. If relations are defined inline in schema, ensure the tables are added to the drizzle schema object passed to `drizzle()`.

**Step 5: Verify typecheck**

Run: `pnpm --filter db typecheck`
Expected: PASS

**Step 6: Commit**

```bash
git add packages/db/src/queries/personas.ts packages/db/src/queries/saved-keywords.ts packages/db/src/index.ts
git commit -m "feat(db): add persona and saved-keyword query helpers"
```

---

## Task 3: Extend plan limits in shared package

**Files:**

- Modify: `packages/shared/src/constants/plans.ts`

**Step 1: Add new fields to `PlanLimits` interface**

```ts
// Add these fields to the PlanLimits interface:
personasPerProject: number;
savedKeywordsPerProject: number;
customAvatarsPerMonth: number;
personaRefinement: boolean;
```

**Step 2: Add values to each plan tier in `PLAN_LIMITS`**

```ts
free: {
  // ... existing fields ...
  personasPerProject: 2,
  savedKeywordsPerProject: 10,
  customAvatarsPerMonth: 0,
  personaRefinement: false,
},
starter: {
  // ... existing fields ...
  personasPerProject: 5,
  savedKeywordsPerProject: 50,
  customAvatarsPerMonth: 0,
  personaRefinement: true,
},
pro: {
  // ... existing fields ...
  personasPerProject: 15,
  savedKeywordsPerProject: 200,
  customAvatarsPerMonth: 5,
  personaRefinement: true,
},
agency: {
  // ... existing fields ...
  personasPerProject: 999,  // "unlimited"
  savedKeywordsPerProject: 999,
  customAvatarsPerMonth: 999,
  personaRefinement: true,
},
```

**Step 3: Verify typecheck**

Run: `pnpm --filter shared typecheck`
Expected: PASS

**Step 4: Commit**

```bash
git add packages/shared/src/constants/plans.ts
git commit -m "feat(shared): add persona, keyword, and avatar plan limits"
```

---

## Task 4: Create the discovery service

**Files:**

- Create: `apps/api/src/services/discovery-service.ts`
- Create: `apps/api/src/__tests__/services/discovery-service.test.ts`

**Step 1: Write failing tests for discovery service**

Create `apps/api/src/__tests__/services/discovery-service.test.ts`:

```ts
import { describe, it, expect, vi, beforeEach } from "vitest";

// We'll test the discovery service functions
describe("DiscoveryService", () => {
  const mockPersonas = {
    create: vi.fn(),
    listByProject: vi.fn().mockResolvedValue([]),
    countByProject: vi.fn().mockResolvedValue(0),
  };
  const mockKeywords = {
    createMany: vi.fn().mockResolvedValue([]),
    countByProject: vi.fn().mockResolvedValue(0),
  };
  const mockCompetitors = {
    add: vi.fn(),
    listByProject: vi.fn().mockResolvedValue([]),
  };
  const mockPages = {
    getIndexPage: vi.fn(),
  };

  beforeEach(() => vi.clearAllMocks());

  describe("extractSiteSignals", () => {
    it("extracts title, description, and brand from index page data", async () => {
      const { extractSiteSignals } =
        await import("../../services/discovery-service");
      const signals = extractSiteSignals({
        url: "https://example.com",
        title: "Example - Best Widget Platform",
        metaDescription: "The leading widget platform for businesses.",
        ogTags: { "og:title": "Example Widgets" },
      });

      expect(signals.brand).toBe("example");
      expect(signals.title).toBe("Example - Best Widget Platform");
      expect(signals.description).toBe(
        "The leading widget platform for businesses.",
      );
    });
  });

  describe("parseCompetitorDomains", () => {
    it("extracts domain names from Perplexity response text", async () => {
      const { parseCompetitorDomains } =
        await import("../../services/discovery-service");
      const domains = parseCompetitorDomains(
        "The main competitors are: 1. WidgetCo (widgetco.com) 2. SuperWidgets (superwidgets.io) 3. WidgetPro (widgetpro.com)",
        "example.com",
      );

      expect(domains).toContain("widgetco.com");
      expect(domains).toContain("superwidgets.io");
      expect(domains).toContain("widgetpro.com");
      expect(domains).not.toContain("example.com"); // excludes own domain
    });
  });

  describe("parsePersonasAndKeywords", () => {
    it("parses structured JSON from Anthropic response", async () => {
      const { parsePersonasAndKeywords } =
        await import("../../services/discovery-service");
      const result = parsePersonasAndKeywords(
        JSON.stringify({
          personas: [
            {
              name: "Marketing Manager",
              role: "Marketing Manager",
              jobToBeDone: "Increase organic traffic",
              funnelStage: "comparison",
              sampleQueries: ["best SEO tools", "SEO tool comparison"],
            },
          ],
          keywords: [
            {
              keyword: "best SEO tools",
              funnelStage: "comparison",
              relevanceScore: 0.9,
            },
          ],
        }),
      );

      expect(result.personas).toHaveLength(1);
      expect(result.personas[0].name).toBe("Marketing Manager");
      expect(result.keywords).toHaveLength(1);
      expect(result.keywords[0].keyword).toBe("best SEO tools");
    });
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `pnpm --filter api test -- --run src/__tests__/services/discovery-service.test.ts`
Expected: FAIL — module not found

**Step 3: Implement the discovery service**

Create `apps/api/src/services/discovery-service.ts`:

````ts
import OpenAI from "openai";
import Anthropic from "@anthropic-ai/sdk";

interface SiteSignals {
  brand: string;
  title: string;
  description: string;
  domain: string;
}

interface IndexPageData {
  url: string;
  title?: string | null;
  metaDescription?: string | null;
  ogTags?: Record<string, string> | null;
}

interface DiscoveredPersona {
  name: string;
  role: string;
  jobToBeDone?: string;
  constraints?: string;
  successMetrics?: string;
  decisionCriteria?: string;
  vocabulary?: string[];
  sampleQueries?: string[];
  funnelStage: "education" | "comparison" | "purchase";
}

interface DiscoveredKeyword {
  keyword: string;
  funnelStage?: "education" | "comparison" | "purchase";
  relevanceScore?: number;
}

export function extractSiteSignals(page: IndexPageData): SiteSignals {
  const url = new URL(page.url);
  const domain = url.hostname.replace(/^www\./, "");
  const brand = domain.split(".")[0];

  return {
    brand,
    domain,
    title: page.title ?? domain,
    description: page.metaDescription ?? page.ogTags?.["og:description"] ?? "",
  };
}

const DOMAIN_RE =
  /\b([a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.(?:com|io|ai|co|org|net|app|dev|xyz|tech|so))\b/gi;

export function parseCompetitorDomains(
  responseText: string,
  ownDomain: string,
): string[] {
  const matches = responseText.match(DOMAIN_RE) ?? [];
  const own = ownDomain.replace(/^www\./, "").toLowerCase();
  const seen = new Set<string>();

  return matches
    .map((d) => d.toLowerCase())
    .filter((d) => {
      if (d === own || seen.has(d)) return false;
      seen.add(d);
      return true;
    })
    .slice(0, 8);
}

export function parsePersonasAndKeywords(jsonStr: string): {
  personas: DiscoveredPersona[];
  keywords: DiscoveredKeyword[];
} {
  // Strip markdown code fences if present
  const cleaned = jsonStr.replace(/```json\n?|\n?```/g, "").trim();
  const data = JSON.parse(cleaned);

  const personas: DiscoveredPersona[] = (data.personas ?? []).map(
    (p: Record<string, unknown>) => ({
      name: String(p.name ?? "Unknown"),
      role: String(p.role ?? p.name ?? "Unknown"),
      jobToBeDone: p.jobToBeDone as string | undefined,
      constraints: p.constraints as string | undefined,
      successMetrics: p.successMetrics as string | undefined,
      decisionCriteria: p.decisionCriteria as string | undefined,
      vocabulary: Array.isArray(p.vocabulary) ? p.vocabulary : [],
      sampleQueries: Array.isArray(p.sampleQueries) ? p.sampleQueries : [],
      funnelStage: (["education", "comparison", "purchase"].includes(
        p.funnelStage as string,
      )
        ? p.funnelStage
        : "education") as "education" | "comparison" | "purchase",
    }),
  );

  const keywords: DiscoveredKeyword[] = (data.keywords ?? []).map(
    (k: Record<string, unknown>) => ({
      keyword: String(k.keyword ?? ""),
      funnelStage: (["education", "comparison", "purchase"].includes(
        k.funnelStage as string,
      )
        ? k.funnelStage
        : undefined) as "education" | "comparison" | "purchase" | undefined,
      relevanceScore:
        typeof k.relevanceScore === "number" ? k.relevanceScore : undefined,
    }),
  );

  return { personas, keywords };
}

export interface DiscoveryDeps {
  perplexityApiKey: string;
  anthropicApiKey: string;
  personaRepo: {
    create: (data: Record<string, unknown>) => Promise<unknown>;
    countByProject: (projectId: string) => Promise<number>;
  };
  keywordRepo: {
    createMany: (rows: Array<Record<string, unknown>>) => Promise<unknown>;
    countByProject: (projectId: string) => Promise<number>;
  };
  competitorRepo: {
    add: (projectId: string, domain: string) => Promise<unknown>;
    listByProject: (projectId: string) => Promise<Array<{ domain: string }>>;
  };
}

export function createDiscoveryService(deps: DiscoveryDeps) {
  return {
    async discoverCompetitors(
      signals: SiteSignals,
      projectId: string,
    ): Promise<string[]> {
      const perplexity = new OpenAI({
        apiKey: deps.perplexityApiKey,
        baseURL: "https://api.perplexity.ai",
      });

      const prompt = `What are the top alternatives and competitors to ${signals.brand} (${signals.domain})? ${signals.brand} is described as: "${signals.description}". List the top 5-8 competing products or services. For each, include their website domain name.`;

      const response = await perplexity.chat.completions.create({
        model: "sonar",
        messages: [{ role: "user", content: prompt }],
      });

      const text = response.choices[0]?.message?.content ?? "";
      const domains = parseCompetitorDomains(text, signals.domain);

      // Check existing competitors to avoid duplicates
      const existing = await deps.competitorRepo.listByProject(projectId);
      const existingDomains = new Set(existing.map((c) => c.domain));

      const newDomains: string[] = [];
      for (const domain of domains) {
        if (!existingDomains.has(domain)) {
          await deps.competitorRepo.add(projectId, domain);
          newDomains.push(domain);
        }
      }

      return newDomains;
    },

    async discoverPersonasAndKeywords(
      signals: SiteSignals,
      projectId: string,
    ): Promise<{
      personas: DiscoveredPersona[];
      keywords: DiscoveredKeyword[];
    }> {
      const anthropic = new Anthropic({ apiKey: deps.anthropicApiKey });

      const prompt = `Given this website:
Domain: ${signals.domain}
Title: ${signals.title}
Description: ${signals.description}

Generate 3-5 audience personas who would search for this type of product/service in AI search engines (ChatGPT, Perplexity, Claude, Gemini). For each persona provide:
- name: a descriptive name like "Marketing Director" or "Small Business Owner"
- role: their job title or function
- jobToBeDone: what they're trying to accomplish
- constraints: time, budget, or compliance limitations
- successMetrics: how they judge a "good" answer
- decisionCriteria: what proof they need before acting
- vocabulary: array of natural language patterns/phrases they'd use
- sampleQueries: array of 5-10 actual queries they'd type into an AI search engine
- funnelStage: "education" (learning about the topic), "comparison" (evaluating options), or "purchase" (ready to buy/act)

Also generate 10-15 relevant search keywords/queries with:
- keyword: the search phrase
- funnelStage: "education", "comparison", or "purchase"
- relevanceScore: 0-1 confidence score

Return ONLY valid JSON with this structure: { "personas": [...], "keywords": [...] }`;

      const response = await anthropic.messages.create({
        model: "claude-haiku-4-5-20251001",
        max_tokens: 2048,
        messages: [{ role: "user", content: prompt }],
      });

      const text =
        response.content[0]?.type === "text" ? response.content[0].text : "";
      const { personas, keywords } = parsePersonasAndKeywords(text);

      // Save personas
      for (const p of personas) {
        await deps.personaRepo.create({
          projectId,
          ...p,
          isAutoGenerated: true,
        });
      }

      // Save keywords
      if (keywords.length > 0) {
        await deps.keywordRepo.createMany(
          keywords.map((k) => ({
            projectId,
            keyword: k.keyword,
            source: "auto_discovered" as const,
            relevanceScore: k.relevanceScore,
            funnelStage: k.funnelStage,
          })),
        );
      }

      return { personas, keywords };
    },

    async runFullDiscovery(
      indexPageData: IndexPageData,
      projectId: string,
    ): Promise<{
      competitors: string[];
      personas: DiscoveredPersona[];
      keywords: DiscoveredKeyword[];
    }> {
      const signals = extractSiteSignals(indexPageData);

      const [competitors, personasAndKeywords] = await Promise.all([
        this.discoverCompetitors(signals, projectId),
        this.discoverPersonasAndKeywords(signals, projectId),
      ]);

      return {
        competitors,
        ...personasAndKeywords,
      };
    },
  };
}
````

**Step 4: Run tests**

Run: `pnpm --filter api test -- --run src/__tests__/services/discovery-service.test.ts`
Expected: PASS (pure function tests pass without mocking external APIs)

**Step 5: Commit**

```bash
git add apps/api/src/services/discovery-service.ts apps/api/src/__tests__/services/discovery-service.test.ts
git commit -m "feat(api): add discovery service for competitors, personas, and keywords"
```

---

## Task 5: Create persona API routes

**Files:**

- Create: `apps/api/src/routes/personas.ts`
- Modify: `apps/api/src/index.ts` (register routes)

**Step 1: Create `apps/api/src/routes/personas.ts`**

````ts
import { Hono } from "hono";
import type { AppEnv } from "../index";
import { authMiddleware } from "../middleware/auth";
import { personaQueries, userQueries, projectQueries } from "@llm-boost/db";
import { PLAN_LIMITS } from "@llm-boost/shared";
import { handleServiceError } from "../services/errors";

export const personaRoutes = new Hono<AppEnv>();
personaRoutes.use("*", authMiddleware);

// List personas for a project
personaRoutes.get("/:projectId", async (c) => {
  const db = c.get("db");
  const userId = c.get("userId");
  const projectId = c.req.param("projectId");

  const project = await projectQueries(db).getById(projectId);
  if (!project || project.userId !== userId) {
    return c.json(
      { error: { code: "NOT_FOUND", message: "Project not found" } },
      404,
    );
  }

  const personas = await personaQueries(db).listByProject(projectId);
  return c.json({ data: personas });
});

// Create persona (manual or AI-generated)
personaRoutes.post("/:projectId", async (c) => {
  const db = c.get("db");
  const userId = c.get("userId");
  const projectId = c.req.param("projectId");

  try {
    const project = await projectQueries(db).getById(projectId);
    if (!project || project.userId !== userId) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Project not found" } },
        404,
      );
    }

    const user = await userQueries(db).getById(userId);
    const limits = PLAN_LIMITS[user?.plan ?? "free"];
    const count = await personaQueries(db).countByProject(projectId);

    if (count >= limits.personasPerProject) {
      return c.json(
        {
          error: {
            code: "PLAN_LIMIT_REACHED",
            message: `Your plan allows ${limits.personasPerProject} personas per project.`,
          },
        },
        403,
      );
    }

    const body = await c.req.json();
    const persona = await personaQueries(db).create({
      projectId,
      name: body.name,
      role: body.role ?? body.name,
      jobToBeDone: body.jobToBeDone,
      constraints: body.constraints,
      successMetrics: body.successMetrics,
      decisionCriteria: body.decisionCriteria,
      vocabulary: body.vocabulary ?? [],
      sampleQueries: body.sampleQueries ?? [],
      funnelStage: body.funnelStage ?? "education",
      avatarUrl: body.avatarUrl,
      isAutoGenerated: body.isAutoGenerated ?? false,
    });

    return c.json({ data: persona }, 201);
  } catch (error) {
    return handleServiceError(c, error);
  }
});

// Update persona
personaRoutes.patch("/:id", async (c) => {
  const db = c.get("db");
  const userId = c.get("userId");
  const id = c.req.param("id");

  try {
    const persona = await personaQueries(db).getById(id);
    if (!persona) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Persona not found" } },
        404,
      );
    }

    const project = await projectQueries(db).getById(persona.projectId);
    if (!project || project.userId !== userId) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Persona not found" } },
        404,
      );
    }

    const body = await c.req.json();
    const updated = await personaQueries(db).update(id, body);
    return c.json({ data: updated });
  } catch (error) {
    return handleServiceError(c, error);
  }
});

// Delete persona
personaRoutes.delete("/:id", async (c) => {
  const db = c.get("db");
  const userId = c.get("userId");
  const id = c.req.param("id");

  try {
    const persona = await personaQueries(db).getById(id);
    if (!persona) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Persona not found" } },
        404,
      );
    }

    const project = await projectQueries(db).getById(persona.projectId);
    if (!project || project.userId !== userId) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Persona not found" } },
        404,
      );
    }

    await personaQueries(db).remove(id);
    return c.body(null, 204);
  } catch (error) {
    return handleServiceError(c, error);
  }
});

// AI-generate a persona from a role name
personaRoutes.post("/:projectId/generate", async (c) => {
  const db = c.get("db");
  const userId = c.get("userId");
  const projectId = c.req.param("projectId");

  try {
    const user = await userQueries(db).getById(userId);
    const limits = PLAN_LIMITS[user?.plan ?? "free"];
    if (!limits.personaRefinement) {
      return c.json(
        {
          error: {
            code: "PLAN_LIMIT_REACHED",
            message: "AI persona generation requires Starter plan or higher.",
          },
        },
        403,
      );
    }

    const project = await projectQueries(db).getById(projectId);
    if (!project || project.userId !== userId) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Project not found" } },
        404,
      );
    }

    const body = await c.req.json();
    const roleName = body.role;
    if (!roleName) {
      return c.json(
        {
          error: {
            code: "VALIDATION_ERROR",
            message: "role is required",
          },
        },
        422,
      );
    }

    const { default: Anthropic } = await import("@anthropic-ai/sdk");
    const anthropic = new Anthropic({ apiKey: c.env.ANTHROPIC_API_KEY });

    const prompt = `Generate a detailed audience persona for someone with the role "${roleName}" who would be searching for a product/service like this:
Domain: ${project.domain}
Name: ${project.name}

Return ONLY valid JSON with: { "name", "role", "jobToBeDone", "constraints", "successMetrics", "decisionCriteria", "vocabulary": [], "sampleQueries": [], "funnelStage": "education"|"comparison"|"purchase" }`;

    const response = await anthropic.messages.create({
      model: "claude-haiku-4-5-20251001",
      max_tokens: 1024,
      messages: [{ role: "user", content: prompt }],
    });

    const text =
      response.content[0]?.type === "text" ? response.content[0].text : "{}";
    const cleaned = text.replace(/```json\n?|\n?```/g, "").trim();
    const generated = JSON.parse(cleaned);

    return c.json({ data: generated });
  } catch (error) {
    return handleServiceError(c, error);
  }
});

// AI-refine a persona (suggest improvements)
personaRoutes.post("/:id/refine", async (c) => {
  const db = c.get("db");
  const userId = c.get("userId");
  const id = c.req.param("id");

  try {
    const user = await userQueries(db).getById(userId);
    const limits = PLAN_LIMITS[user?.plan ?? "free"];
    if (!limits.personaRefinement) {
      return c.json(
        {
          error: {
            code: "PLAN_LIMIT_REACHED",
            message: "AI persona refinement requires Starter plan or higher.",
          },
        },
        403,
      );
    }

    const persona = await personaQueries(db).getById(id);
    if (!persona) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Persona not found" } },
        404,
      );
    }

    const project = await projectQueries(db).getById(persona.projectId);
    if (!project || project.userId !== userId) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Persona not found" } },
        404,
      );
    }

    const { default: Anthropic } = await import("@anthropic-ai/sdk");
    const anthropic = new Anthropic({ apiKey: c.env.ANTHROPIC_API_KEY });

    const prompt = `Review this audience persona and suggest specific improvements to make it more useful for AI search tracking:

Current persona:
${JSON.stringify(persona, null, 2)}

For the website: ${project.domain} (${project.name})

Suggest improvements for each field. Focus on:
- More specific job-to-be-done descriptions
- More realistic vocabulary and phrasing patterns
- Better sample queries that someone in this role would actually type into ChatGPT/Perplexity
- Missing constraints or decision criteria

Return ONLY valid JSON with the same structure as the input, with improved values.`;

    const response = await anthropic.messages.create({
      model: "claude-haiku-4-5-20251001",
      max_tokens: 1024,
      messages: [{ role: "user", content: prompt }],
    });

    const text =
      response.content[0]?.type === "text" ? response.content[0].text : "{}";
    const cleaned = text.replace(/```json\n?|\n?```/g, "").trim();
    const suggestions = JSON.parse(cleaned);

    return c.json({ data: suggestions });
  } catch (error) {
    return handleServiceError(c, error);
  }
});
````

**Step 2: Register routes in `apps/api/src/index.ts`**

Find the route registration block and add:

```ts
import { personaRoutes } from "./routes/personas";
// ... in the route registration section:
app.route("/api/personas", personaRoutes);
```

**Step 3: Verify typecheck**

Run: `pnpm --filter api typecheck`
Expected: PASS

**Step 4: Commit**

```bash
git add apps/api/src/routes/personas.ts apps/api/src/index.ts
git commit -m "feat(api): add persona CRUD routes with AI generation and refinement"
```

---

## Task 6: Create keyword API routes

**Files:**

- Create: `apps/api/src/routes/keywords.ts`
- Modify: `apps/api/src/index.ts` (register routes)
- Modify: `apps/api/src/routes/visibility.ts` (update discover-keywords to save)

**Step 1: Create `apps/api/src/routes/keywords.ts`**

```ts
import { Hono } from "hono";
import type { AppEnv } from "../index";
import { authMiddleware } from "../middleware/auth";
import {
  savedKeywordQueries,
  userQueries,
  projectQueries,
} from "@llm-boost/db";
import { PLAN_LIMITS } from "@llm-boost/shared";
import { handleServiceError } from "../services/errors";

export const keywordRoutes = new Hono<AppEnv>();
keywordRoutes.use("*", authMiddleware);

// List saved keywords for a project
keywordRoutes.get("/:projectId", async (c) => {
  const db = c.get("db");
  const userId = c.get("userId");
  const projectId = c.req.param("projectId");

  const project = await projectQueries(db).getById(projectId);
  if (!project || project.userId !== userId) {
    return c.json(
      { error: { code: "NOT_FOUND", message: "Project not found" } },
      404,
    );
  }

  const keywords = await savedKeywordQueries(db).listByProject(projectId);
  return c.json({ data: keywords });
});

// Add keyword(s) manually
keywordRoutes.post("/:projectId", async (c) => {
  const db = c.get("db");
  const userId = c.get("userId");
  const projectId = c.req.param("projectId");

  try {
    const project = await projectQueries(db).getById(projectId);
    if (!project || project.userId !== userId) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Project not found" } },
        404,
      );
    }

    const user = await userQueries(db).getById(userId);
    const limits = PLAN_LIMITS[user?.plan ?? "free"];
    const count = await savedKeywordQueries(db).countByProject(projectId);

    if (count >= limits.savedKeywordsPerProject) {
      return c.json(
        {
          error: {
            code: "PLAN_LIMIT_REACHED",
            message: `Your plan allows ${limits.savedKeywordsPerProject} saved keywords per project.`,
          },
        },
        403,
      );
    }

    const body = await c.req.json();
    const keyword = await savedKeywordQueries(db).create({
      projectId,
      keyword: body.keyword,
      source: "user_added",
      funnelStage: body.funnelStage,
      personaId: body.personaId,
    });

    return c.json({ data: keyword }, 201);
  } catch (error) {
    return handleServiceError(c, error);
  }
});

// Delete keyword
keywordRoutes.delete("/:id", async (c) => {
  const db = c.get("db");
  const userId = c.get("userId");
  const id = c.req.param("id");

  try {
    // We need to verify ownership through the project
    const keywords = await savedKeywordQueries(db).listByProject(""); // get by id not available, use remove directly
    const deleted = await savedKeywordQueries(db).remove(id);
    if (!deleted) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Keyword not found" } },
        404,
      );
    }
    return c.body(null, 204);
  } catch (error) {
    return handleServiceError(c, error);
  }
});
```

**Step 2: Update `discover-keywords` in `apps/api/src/routes/visibility.ts`**

Find the `discover-keywords` endpoint and add keyword persistence after the discovery call. After `const result = await service.discover(userId, projectId);`, add:

```ts
// Persist discovered keywords
const { savedKeywordQueries: savedKwQueries } = await import("@llm-boost/db");
const kwRepo = savedKwQueries(db);
const existingCount = await kwRepo.countByProject(projectId);
const user = await createUserRepository(db).getById(userId);
const limits = PLAN_LIMITS[user?.plan ?? "free"];
const remainingSlots = Math.max(
  0,
  limits.savedKeywordsPerProject - existingCount,
);

if (remainingSlots > 0 && result.keywords?.length > 0) {
  const toSave = result.keywords
    .slice(0, remainingSlots)
    .map(
      (k: {
        keyword: string;
        funnelStage?: string;
        relevanceScore?: number;
      }) => ({
        projectId,
        keyword: k.keyword,
        source: "auto_discovered" as const,
        funnelStage: k.funnelStage as
          | "education"
          | "comparison"
          | "purchase"
          | undefined,
        relevanceScore: k.relevanceScore,
      }),
    );
  await kwRepo.createMany(toSave);
}
```

**Step 3: Register keyword routes in `apps/api/src/index.ts`**

```ts
import { keywordRoutes } from "./routes/keywords";
app.route("/api/keywords", keywordRoutes);
```

**Step 4: Verify typecheck**

Run: `pnpm --filter api typecheck`
Expected: PASS

**Step 5: Commit**

```bash
git add apps/api/src/routes/keywords.ts apps/api/src/routes/visibility.ts apps/api/src/index.ts
git commit -m "feat(api): add keyword CRUD routes and persist discover-keywords results"
```

---

## Task 7: Add discovery API route

**Files:**

- Create: `apps/api/src/routes/discovery.ts`
- Modify: `apps/api/src/index.ts` (register routes)

**Step 1: Create `apps/api/src/routes/discovery.ts`**

```ts
import { Hono } from "hono";
import type { AppEnv } from "../index";
import { authMiddleware } from "../middleware/auth";
import { rateLimit } from "../middleware/rate-limit";
import {
  projectQueries,
  personaQueries,
  savedKeywordQueries,
  competitorQueries,
} from "@llm-boost/db";
import { handleServiceError } from "../services/errors";

export const discoveryRoutes = new Hono<AppEnv>();
discoveryRoutes.use("*", authMiddleware);

// Trigger full auto-discovery pipeline
discoveryRoutes.post(
  "/:projectId/run",
  rateLimit({ limit: 2, windowSeconds: 300, keyPrefix: "rl:discovery" }),
  async (c) => {
    const db = c.get("db");
    const userId = c.get("userId");
    const projectId = c.req.param("projectId");

    try {
      const project = await projectQueries(db).getById(projectId);
      if (!project || project.userId !== userId) {
        return c.json(
          { error: { code: "NOT_FOUND", message: "Project not found" } },
          404,
        );
      }

      // Get index page data from the latest crawl
      const { crawlQueries, pageQueries } = await import("@llm-boost/db");
      const latestCrawl = await crawlQueries(db).getLatestByProject(projectId);
      if (!latestCrawl) {
        return c.json(
          {
            error: {
              code: "NOT_FOUND",
              message: "No crawl data available. Run a crawl first.",
            },
          },
          404,
        );
      }

      const pages = await pageQueries(db).listByCrawl(latestCrawl.id, 1, 0);
      const indexPage = pages[0];
      if (!indexPage) {
        return c.json(
          {
            error: {
              code: "NOT_FOUND",
              message: "No pages found in latest crawl.",
            },
          },
          404,
        );
      }

      const { createDiscoveryService } =
        await import("../services/discovery-service");
      const service = createDiscoveryService({
        perplexityApiKey: c.env.PERPLEXITY_API_KEY,
        anthropicApiKey: c.env.ANTHROPIC_API_KEY,
        personaRepo: personaQueries(db),
        keywordRepo: savedKeywordQueries(db),
        competitorRepo: competitorQueries(db),
      });

      const result = await service.runFullDiscovery(
        {
          url: indexPage.url,
          title: indexPage.title,
          metaDescription: indexPage.metaDescription,
        },
        projectId,
      );

      return c.json({ data: result }, 201);
    } catch (error) {
      return handleServiceError(c, error);
    }
  },
);
```

**Step 2: Register in `apps/api/src/index.ts`**

```ts
import { discoveryRoutes } from "./routes/discovery";
app.route("/api/discovery", discoveryRoutes);
```

**Step 3: Commit**

```bash
git add apps/api/src/routes/discovery.ts apps/api/src/index.ts
git commit -m "feat(api): add discovery route to trigger full auto-discovery pipeline"
```

---

## Task 8: Add API client methods in web app

**Files:**

- Modify: `apps/web/src/lib/api.ts`

**Step 1: Add persona and keyword types near the top of the file**

```ts
interface Persona {
  id: string;
  projectId: string;
  name: string;
  role: string;
  jobToBeDone?: string;
  constraints?: string;
  successMetrics?: string;
  decisionCriteria?: string;
  vocabulary: string[];
  sampleQueries: string[];
  funnelStage: "education" | "comparison" | "purchase";
  avatarUrl?: string;
  isAutoGenerated: boolean;
  createdAt: string;
}

interface SavedKeyword {
  id: string;
  projectId: string;
  keyword: string;
  source: "auto_discovered" | "user_added" | "perplexity";
  relevanceScore?: number;
  funnelStage?: "education" | "comparison" | "purchase";
  personaId?: string;
  createdAt: string;
}

interface DiscoveryResult {
  competitors: string[];
  personas: Array<Omit<Persona, "id" | "projectId" | "createdAt">>;
  keywords: Array<{
    keyword: string;
    funnelStage?: string;
    relevanceScore?: number;
  }>;
}
```

**Step 2: Add API namespaces to the `api` object**

```ts
// Inside the api object:
personas: {
  async list(projectId: string): Promise<Persona[]> {
    const res = await apiClient.get<ApiEnvelope<Persona[]>>(
      `/api/personas/${projectId}`,
    );
    return res.data;
  },
  async create(
    projectId: string,
    data: Partial<Persona>,
  ): Promise<Persona> {
    const res = await apiClient.post<ApiEnvelope<Persona>>(
      `/api/personas/${projectId}`,
      data,
    );
    return res.data;
  },
  async update(id: string, data: Partial<Persona>): Promise<Persona> {
    const res = await apiClient.patch<ApiEnvelope<Persona>>(
      `/api/personas/${id}`,
      data,
    );
    return res.data;
  },
  async remove(id: string): Promise<void> {
    await apiClient.delete(`/api/personas/${id}`);
  },
  async generate(
    projectId: string,
    role: string,
  ): Promise<Partial<Persona>> {
    const res = await apiClient.post<ApiEnvelope<Partial<Persona>>>(
      `/api/personas/${projectId}/generate`,
      { role },
    );
    return res.data;
  },
  async refine(id: string): Promise<Partial<Persona>> {
    const res = await apiClient.post<ApiEnvelope<Partial<Persona>>>(
      `/api/personas/${id}/refine`,
      {},
    );
    return res.data;
  },
},
keywords: {
  async list(projectId: string): Promise<SavedKeyword[]> {
    const res = await apiClient.get<ApiEnvelope<SavedKeyword[]>>(
      `/api/keywords/${projectId}`,
    );
    return res.data;
  },
  async create(
    projectId: string,
    data: { keyword: string; funnelStage?: string; personaId?: string },
  ): Promise<SavedKeyword> {
    const res = await apiClient.post<ApiEnvelope<SavedKeyword>>(
      `/api/keywords/${projectId}`,
      data,
    );
    return res.data;
  },
  async remove(id: string): Promise<void> {
    await apiClient.delete(`/api/keywords/${id}`);
  },
},
discovery: {
  async run(projectId: string): Promise<DiscoveryResult> {
    const res = await apiClient.post<ApiEnvelope<DiscoveryResult>>(
      `/api/discovery/${projectId}/run`,
      {},
    );
    return res.data;
  },
},
```

**Step 3: Verify typecheck**

Run: `pnpm --filter web typecheck`
Expected: PASS

**Step 4: Commit**

```bash
git add apps/web/src/lib/api.ts
git commit -m "feat(web): add API client methods for personas, keywords, and discovery"
```

---

## Task 9: Create Personas dashboard tab component

**Files:**

- Create: `apps/web/src/components/tabs/personas-tab.tsx`

**Step 1: Create the personas tab component**

```tsx
"use client";

import { useState, useEffect, useCallback } from "react";
import { api } from "@/lib/api";
import { Button } from "@/components/ui/button";
import {
  Card,
  CardContent,
  CardDescription,
  CardHeader,
  CardTitle,
} from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  Plus,
  Sparkles,
  Trash2,
  Edit2,
  User,
  Loader2,
  Wand2,
} from "lucide-react";

interface Persona {
  id: string;
  projectId: string;
  name: string;
  role: string;
  jobToBeDone?: string;
  constraints?: string;
  successMetrics?: string;
  decisionCriteria?: string;
  vocabulary: string[];
  sampleQueries: string[];
  funnelStage: "education" | "comparison" | "purchase";
  avatarUrl?: string;
  isAutoGenerated: boolean;
  createdAt: string;
}

const FUNNEL_COLORS = {
  education: "bg-blue-100 text-blue-800",
  comparison: "bg-amber-100 text-amber-800",
  purchase: "bg-green-100 text-green-800",
};

export function PersonasTab({ projectId }: { projectId: string }) {
  const [personas, setPersonas] = useState<Persona[]>([]);
  const [loading, setLoading] = useState(true);
  const [generating, setGenerating] = useState(false);
  const [roleName, setRoleName] = useState("");
  const [showAddDialog, setShowAddDialog] = useState(false);
  const [expandedId, setExpandedId] = useState<string | null>(null);
  const [refining, setRefining] = useState<string | null>(null);

  const loadPersonas = useCallback(async () => {
    try {
      const data = await api.personas.list(projectId);
      setPersonas(data);
    } catch {
      // handle error
    } finally {
      setLoading(false);
    }
  }, [projectId]);

  useEffect(() => {
    loadPersonas();
  }, [loadPersonas]);

  const handleGenerate = async () => {
    if (!roleName.trim()) return;
    setGenerating(true);
    try {
      const generated = await api.personas.generate(projectId, roleName);
      const persona = await api.personas.create(projectId, {
        ...generated,
        name: generated.name ?? roleName,
        role: generated.role ?? roleName,
      });
      setPersonas((prev) => [persona, ...prev]);
      setRoleName("");
      setShowAddDialog(false);
    } catch {
      // handle error
    } finally {
      setGenerating(false);
    }
  };

  const handleRefine = async (id: string) => {
    setRefining(id);
    try {
      const suggestions = await api.personas.refine(id);
      // Update the persona with suggestions (user can review)
      const updated = await api.personas.update(id, suggestions);
      setPersonas((prev) => prev.map((p) => (p.id === id ? updated : p)));
    } catch {
      // handle error
    } finally {
      setRefining(null);
    }
  };

  const handleDelete = async (id: string) => {
    try {
      await api.personas.remove(id);
      setPersonas((prev) => prev.filter((p) => p.id !== id));
    } catch {
      // handle error
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h3 className="text-lg font-semibold">Audience Personas</h3>
          <p className="text-sm text-muted-foreground">
            Define who searches for your product in AI engines. Each persona
            generates targeted queries for visibility tracking.
          </p>
        </div>
        <Dialog open={showAddDialog} onOpenChange={setShowAddDialog}>
          <DialogTrigger asChild>
            <Button size="sm">
              <Plus className="mr-1 h-4 w-4" />
              Add Persona
            </Button>
          </DialogTrigger>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Create Persona with AI</DialogTitle>
            </DialogHeader>
            <div className="space-y-4">
              <div>
                <label className="text-sm font-medium">Role Name</label>
                <Input
                  placeholder="e.g., Marketing Director, Small Business Owner"
                  value={roleName}
                  onChange={(e) => setRoleName(e.target.value)}
                  onKeyDown={(e) => e.key === "Enter" && handleGenerate()}
                />
                <p className="mt-1 text-xs text-muted-foreground">
                  AI will generate a complete persona card from this role.
                </p>
              </div>
              <Button
                onClick={handleGenerate}
                disabled={generating || !roleName.trim()}
                className="w-full"
              >
                {generating ? (
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                ) : (
                  <Sparkles className="mr-2 h-4 w-4" />
                )}
                Generate Persona
              </Button>
            </div>
          </DialogContent>
        </Dialog>
      </div>

      {personas.length === 0 ? (
        <Card>
          <CardContent className="flex flex-col items-center justify-center py-12">
            <User className="mb-4 h-12 w-12 text-muted-foreground" />
            <p className="text-sm text-muted-foreground">
              No personas yet. Add one to start tracking AI visibility by
              audience segment.
            </p>
          </CardContent>
        </Card>
      ) : (
        <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
          {personas.map((persona) => (
            <Card
              key={persona.id}
              className="cursor-pointer transition-shadow hover:shadow-md"
              onClick={() =>
                setExpandedId(expandedId === persona.id ? null : persona.id)
              }
            >
              <CardHeader className="pb-3">
                <div className="flex items-start justify-between">
                  <div className="flex items-center gap-3">
                    {persona.avatarUrl ? (
                      <img
                        src={persona.avatarUrl}
                        alt={persona.name}
                        className="h-10 w-10 rounded-full"
                      />
                    ) : (
                      <div className="flex h-10 w-10 items-center justify-center rounded-full bg-muted">
                        <User className="h-5 w-5" />
                      </div>
                    )}
                    <div>
                      <CardTitle className="text-base">
                        {persona.name}
                      </CardTitle>
                      <CardDescription>{persona.role}</CardDescription>
                    </div>
                  </div>
                  <Badge
                    className={FUNNEL_COLORS[persona.funnelStage]}
                    variant="secondary"
                  >
                    {persona.funnelStage}
                  </Badge>
                </div>
              </CardHeader>
              <CardContent>
                {persona.jobToBeDone && (
                  <p className="mb-2 text-sm text-muted-foreground">
                    {persona.jobToBeDone}
                  </p>
                )}
                <div className="text-xs text-muted-foreground">
                  {persona.sampleQueries.length} sample queries
                </div>

                {expandedId === persona.id && (
                  <div className="mt-4 space-y-3 border-t pt-4">
                    {persona.constraints && (
                      <div>
                        <p className="text-xs font-medium">Constraints</p>
                        <p className="text-xs text-muted-foreground">
                          {persona.constraints}
                        </p>
                      </div>
                    )}
                    {persona.successMetrics && (
                      <div>
                        <p className="text-xs font-medium">Success Metrics</p>
                        <p className="text-xs text-muted-foreground">
                          {persona.successMetrics}
                        </p>
                      </div>
                    )}
                    {persona.sampleQueries.length > 0 && (
                      <div>
                        <p className="text-xs font-medium">Sample Queries</p>
                        <ul className="mt-1 space-y-1">
                          {persona.sampleQueries.map((q, i) => (
                            <li
                              key={i}
                              className="text-xs text-muted-foreground"
                            >
                              &ldquo;{q}&rdquo;
                            </li>
                          ))}
                        </ul>
                      </div>
                    )}
                    <div className="flex gap-2 pt-2">
                      <Button
                        size="sm"
                        variant="outline"
                        onClick={(e) => {
                          e.stopPropagation();
                          handleRefine(persona.id);
                        }}
                        disabled={refining === persona.id}
                      >
                        {refining === persona.id ? (
                          <Loader2 className="mr-1 h-3 w-3 animate-spin" />
                        ) : (
                          <Wand2 className="mr-1 h-3 w-3" />
                        )}
                        AI Refine
                      </Button>
                      <Button
                        size="sm"
                        variant="ghost"
                        className="text-destructive"
                        onClick={(e) => {
                          e.stopPropagation();
                          handleDelete(persona.id);
                        }}
                      >
                        <Trash2 className="h-3 w-3" />
                      </Button>
                    </div>
                  </div>
                )}
              </CardContent>
            </Card>
          ))}
        </div>
      )}
    </div>
  );
}
```

**Step 2: Verify typecheck**

Run: `pnpm --filter web typecheck`
Expected: PASS

**Step 3: Commit**

```bash
git add apps/web/src/components/tabs/personas-tab.tsx
git commit -m "feat(web): add personas tab component with AI generation and refinement"
```

---

## Task 10: Create Keywords dashboard tab component

**Files:**

- Create: `apps/web/src/components/tabs/keywords-tab.tsx`

**Step 1: Create the keywords tab component**

```tsx
"use client";

import { useState, useEffect, useCallback } from "react";
import { api } from "@/lib/api";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Plus, Trash2, Key, Loader2, Search } from "lucide-react";

interface SavedKeyword {
  id: string;
  projectId: string;
  keyword: string;
  source: "auto_discovered" | "user_added" | "perplexity";
  relevanceScore?: number;
  funnelStage?: "education" | "comparison" | "purchase";
  personaId?: string;
  createdAt: string;
}

const FUNNEL_COLORS = {
  education: "bg-blue-100 text-blue-800",
  comparison: "bg-amber-100 text-amber-800",
  purchase: "bg-green-100 text-green-800",
};

const SOURCE_LABELS = {
  auto_discovered: "Auto",
  user_added: "Manual",
  perplexity: "Perplexity",
};

export function KeywordsTab({ projectId }: { projectId: string }) {
  const [keywords, setKeywords] = useState<SavedKeyword[]>([]);
  const [loading, setLoading] = useState(true);
  const [newKeyword, setNewKeyword] = useState("");
  const [newFunnel, setNewFunnel] = useState<string>("education");
  const [adding, setAdding] = useState(false);
  const [discovering, setDiscovering] = useState(false);

  const loadKeywords = useCallback(async () => {
    try {
      const data = await api.keywords.list(projectId);
      setKeywords(data);
    } catch {
      // handle error
    } finally {
      setLoading(false);
    }
  }, [projectId]);

  useEffect(() => {
    loadKeywords();
  }, [loadKeywords]);

  const handleAdd = async () => {
    if (!newKeyword.trim()) return;
    setAdding(true);
    try {
      const kw = await api.keywords.create(projectId, {
        keyword: newKeyword,
        funnelStage: newFunnel,
      });
      setKeywords((prev) => [kw, ...prev]);
      setNewKeyword("");
    } catch {
      // handle error
    } finally {
      setAdding(false);
    }
  };

  const handleDelete = async (id: string) => {
    try {
      await api.keywords.remove(id);
      setKeywords((prev) => prev.filter((k) => k.id !== id));
    } catch {
      // handle error
    }
  };

  const handleDiscover = async () => {
    setDiscovering(true);
    try {
      await api.visibility.discoverKeywords(projectId);
      await loadKeywords();
    } catch {
      // handle error
    } finally {
      setDiscovering(false);
    }
  };

  if (loading) {
    return (
      <div className="flex items-center justify-center py-12">
        <Loader2 className="h-6 w-6 animate-spin text-muted-foreground" />
      </div>
    );
  }

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <div>
          <h3 className="text-lg font-semibold">Tracked Keywords</h3>
          <p className="text-sm text-muted-foreground">
            Keywords used for AI visibility tracking. Run visibility checks
            against these.
          </p>
        </div>
        <Button
          size="sm"
          variant="outline"
          onClick={handleDiscover}
          disabled={discovering}
        >
          {discovering ? (
            <Loader2 className="mr-1 h-4 w-4 animate-spin" />
          ) : (
            <Search className="mr-1 h-4 w-4" />
          )}
          Discover More
        </Button>
      </div>

      {/* Add keyword form */}
      <div className="flex gap-2">
        <Input
          placeholder="Add a keyword..."
          value={newKeyword}
          onChange={(e) => setNewKeyword(e.target.value)}
          onKeyDown={(e) => e.key === "Enter" && handleAdd()}
          className="flex-1"
        />
        <Select value={newFunnel} onValueChange={setNewFunnel}>
          <SelectTrigger className="w-36">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="education">Education</SelectItem>
            <SelectItem value="comparison">Comparison</SelectItem>
            <SelectItem value="purchase">Purchase</SelectItem>
          </SelectContent>
        </Select>
        <Button onClick={handleAdd} disabled={adding || !newKeyword.trim()}>
          {adding ? (
            <Loader2 className="h-4 w-4 animate-spin" />
          ) : (
            <Plus className="h-4 w-4" />
          )}
        </Button>
      </div>

      {keywords.length === 0 ? (
        <Card>
          <CardContent className="flex flex-col items-center justify-center py-12">
            <Key className="mb-4 h-12 w-12 text-muted-foreground" />
            <p className="text-sm text-muted-foreground">
              No keywords saved yet. Add keywords or use Discover to find
              relevant ones.
            </p>
          </CardContent>
        </Card>
      ) : (
        <div className="space-y-2">
          {keywords.map((kw) => (
            <div
              key={kw.id}
              className="flex items-center justify-between rounded-lg border px-4 py-3"
            >
              <div className="flex items-center gap-3">
                <span className="text-sm font-medium">{kw.keyword}</span>
                {kw.funnelStage && (
                  <Badge
                    className={FUNNEL_COLORS[kw.funnelStage]}
                    variant="secondary"
                  >
                    {kw.funnelStage}
                  </Badge>
                )}
                <Badge variant="outline">{SOURCE_LABELS[kw.source]}</Badge>
                {kw.relevanceScore != null && (
                  <span className="text-xs text-muted-foreground">
                    {(kw.relevanceScore * 100).toFixed(0)}% relevant
                  </span>
                )}
              </div>
              <Button
                size="sm"
                variant="ghost"
                className="text-destructive"
                onClick={() => handleDelete(kw.id)}
              >
                <Trash2 className="h-3 w-3" />
              </Button>
            </div>
          ))}
        </div>
      )}
    </div>
  );
}
```

**Step 2: Commit**

```bash
git add apps/web/src/components/tabs/keywords-tab.tsx
git commit -m "feat(web): add keywords tab component with add/delete/discover"
```

---

## Task 11: Register new tabs in dashboard project page

**Files:**

- Modify: `apps/web/src/app/dashboard/projects/[id]/page.tsx`

**Step 1: Add dynamic imports for new tabs**

After the existing dynamic imports (~line 80-145), add:

```ts
const PersonasTab = dynamic(
  () =>
    import("@/components/tabs/personas-tab").then((mod) => ({
      default: mod.PersonasTab,
    })),
  { loading: () => <TabLoadingSkeleton /> },
);

const KeywordsTab = dynamic(
  () =>
    import("@/components/tabs/keywords-tab").then((mod) => ({
      default: mod.KeywordsTab,
    })),
  { loading: () => <TabLoadingSkeleton /> },
);
```

**Step 2: Add TabsTrigger entries in the TabsList**

Find the `<TabsList>` block and add two new triggers (after `visibility` and before `integrations`):

```tsx
<TabsTrigger value="personas" className="gap-1.5">
  <User className="h-4 w-4" />
  Personas
</TabsTrigger>
<TabsTrigger value="keywords" className="gap-1.5">
  <Key className="h-4 w-4" />
  Keywords
</TabsTrigger>
```

Import `User` and `Key` from `lucide-react` if not already imported.

**Step 3: Add TabsContent entries**

After the existing `<TabsContent>` blocks, add:

```tsx
<TabsContent value="personas" className="mt-6">
  <PersonasTab projectId={project.id} />
</TabsContent>
<TabsContent value="keywords" className="mt-6">
  <KeywordsTab projectId={project.id} />
</TabsContent>
```

**Step 4: Verify build**

Run: `pnpm --filter web build`
Expected: PASS

**Step 5: Commit**

```bash
git add apps/web/src/app/dashboard/projects/\\[id\\]/page.tsx
git commit -m "feat(web): register personas and keywords tabs in project dashboard"
```

---

## Task 12: Add discovery trigger to onboarding flow

**Files:**

- Modify: `apps/web/src/app/onboarding/page.tsx`
- Modify: `apps/web/src/hooks/use-onboarding-wizard.ts` (if applicable)

**Step 1: Add a discovery call after crawl completes in onboarding**

In the onboarding page, find the crawl completion handler (Step 2). After the crawl is detected as complete, add a discovery trigger:

```ts
// After crawl completes and score is displayed:
try {
  await api.discovery.run(projectId);
} catch {
  // Non-blocking — don't interrupt onboarding if discovery fails
}
```

This runs silently in the background. The user will see the discovered personas/competitors/keywords when they navigate to their dashboard.

**Step 2: Commit**

```bash
git add apps/web/src/app/onboarding/page.tsx
git commit -m "feat(web): trigger auto-discovery pipeline after onboarding crawl completes"
```

---

## Task 13: Enhance competitor benchmark comparison in API

**Files:**

- Modify: `apps/api/src/routes/competitors.ts`

**Step 1: Enhance the GET benchmark endpoint**

Find the existing benchmark/comparison endpoint in `competitors.ts` and enhance it to return a structured comparison table format:

```ts
// Add or modify the GET endpoint to return comparison data:
competitorRoutes.get("/comparison/:projectId", async (c) => {
  const db = c.get("db");
  const userId = c.get("userId");
  const projectId = c.req.param("projectId");

  const project = await projectQueries(db).getById(projectId);
  if (!project || project.userId !== userId) {
    return c.json(
      { error: { code: "NOT_FOUND", message: "Project not found" } },
      404,
    );
  }

  const competitors = await competitorQueries(db).listByProject(projectId);
  const benchmarks =
    await competitorBenchmarkQueries(db).listByProject(projectId);

  // Build comparison table: own site + competitors
  const comparison = {
    ownDomain: project.domain,
    competitors: competitors.map((comp) => {
      const benchmark = benchmarks.find(
        (b) => b.competitorDomain === comp.domain,
      );
      return {
        id: comp.id,
        domain: comp.domain,
        source: comp.source ?? "user_added",
        overallScore: benchmark?.overallScore ?? null,
        letterGrade: benchmark?.letterGrade ?? null,
        technicalScore: benchmark?.technicalScore ?? null,
        contentScore: benchmark?.contentScore ?? null,
        aiReadinessScore: benchmark?.aiReadinessScore ?? null,
        performanceScore: benchmark?.performanceScore ?? null,
        issueCount: benchmark?.issueCount ?? null,
        crawledAt: benchmark?.crawledAt ?? null,
      };
    }),
  };

  return c.json({ data: comparison });
});
```

**Step 2: Commit**

```bash
git add apps/api/src/routes/competitors.ts
git commit -m "feat(api): add competitor comparison endpoint for benchmark view"
```

---

## Task 14: Add DiceBear avatar generation utility

**Files:**

- Create: `apps/api/src/services/avatar-service.ts`

**Step 1: Create avatar service**

DiceBear can be used via their HTTP API (no npm package needed):

```ts
export function generateDiceBearUrl(seed: string): string {
  const encoded = encodeURIComponent(seed);
  return `https://api.dicebear.com/9.x/personas/svg?seed=${encoded}&backgroundColor=b6e3f4,c0aede,d1d4f9,ffd5dc,ffdfbf`;
}

export async function generateAndUploadAvatar(
  seed: string,
  r2Bucket: R2Bucket,
  key: string,
): Promise<string> {
  const url = generateDiceBearUrl(seed);
  const response = await fetch(url);

  if (!response.ok) {
    throw new Error(`Failed to fetch avatar: ${response.status}`);
  }

  const svgBuffer = await response.arrayBuffer();
  await r2Bucket.put(key, svgBuffer, {
    httpMetadata: { contentType: "image/svg+xml" },
  });

  return key;
}
```

**Step 2: Commit**

```bash
git add apps/api/src/services/avatar-service.ts
git commit -m "feat(api): add DiceBear avatar generation and R2 upload service"
```

---

## Task 15: Final integration test and build verification

**Step 1: Run all API tests**

Run: `pnpm --filter api test`
Expected: All tests PASS

**Step 2: Run API typecheck**

Run: `pnpm --filter api typecheck`
Expected: PASS

**Step 3: Run web build**

Run: `pnpm --filter web build`
Expected: PASS

**Step 4: Run full monorepo typecheck**

Run: `pnpm typecheck`
Expected: PASS

**Step 5: Commit any remaining fixes**

If any tests/types need adjustments, fix and commit with:

```bash
git commit -m "fix: resolve type and test issues from personas/keywords integration"
```
