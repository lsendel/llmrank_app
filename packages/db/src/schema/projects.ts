import { pgTable, pgEnum, text, integer, real, boolean, timestamp, jsonb, index, uniqueIndex, uuid, varchar } from "drizzle-orm/pg-core";

import { crawlScheduleEnum, funnelStageEnum, keywordSourceEnum } from "./enums";
import { users } from "./identity";

export const projects = pgTable(
  "projects",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    name: text("name").notNull(),
    domain: text("domain").notNull(),
    settings: jsonb("settings").default({}),
    branding: jsonb("branding").default({}),
    crawlSchedule: crawlScheduleEnum("crawl_schedule")
      .notNull()
      .default("manual"),
    nextCrawlAt: timestamp("next_crawl_at"),
    scoringProfileId: uuid("scoring_profile_id"),
    leaderboardOptIn: boolean("leaderboard_opt_in").notNull().default(false),
    teamId: uuid("team_id"),
    siteDescription: text("site_description"),
    industry: text("industry"),
    pipelineSettings: jsonb("pipeline_settings").default({}),
    siteDescriptionSource: text("site_description_source").default("auto"),
    industrySource: text("industry_source").default("auto"),
    deletedAt: timestamp("deleted_at"),
    createdAt: timestamp("created_at").notNull().defaultNow(),
    updatedAt: timestamp("updated_at").notNull().defaultNow(),
  },
  (t) => [index("idx_projects_user").on(t.userId)],
);

export const personas = pgTable(
  "personas",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    projectId: uuid("project_id")
      .notNull()
      .references(() => projects.id, { onDelete: "cascade" }),
    name: text("name").notNull(),
    role: text("role").notNull(),
    jobToBeDone: text("job_to_be_done"),
    constraints: text("constraints"),
    successMetrics: text("success_metrics"),
    decisionCriteria: text("decision_criteria"),
    vocabulary: text("vocabulary").array().default([]),
    sampleQueries: text("sample_queries").array().default([]),
    funnelStage: funnelStageEnum("funnel_stage").notNull().default("education"),
    avatarUrl: text("avatar_url"),
    isAutoGenerated: boolean("is_auto_generated").notNull().default(true),
    createdAt: timestamp("created_at").notNull().defaultNow(),
  },
  (t) => [index("idx_personas_project").on(t.projectId)],
);

export const competitors = pgTable(
  "competitors",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    projectId: uuid("project_id")
      .notNull()
      .references(() => projects.id, { onDelete: "cascade" }),
    domain: text("domain").notNull(),
    source: text("source").notNull().default("user_added"),
    createdAt: timestamp("created_at").notNull().defaultNow(),
  },
  (t) => [index("idx_competitors_project").on(t.projectId)],
);

export const savedKeywords = pgTable(
  "saved_keywords",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    projectId: uuid("project_id")
      .notNull()
      .references(() => projects.id, { onDelete: "cascade" }),
    keyword: text("keyword").notNull(),
    source: keywordSourceEnum("source").notNull().default("user_added"),
    relevanceScore: real("relevance_score"),
    funnelStage: funnelStageEnum("funnel_stage"),
    personaId: uuid("persona_id").references(() => personas.id, {
      onDelete: "set null",
    }),
    createdAt: timestamp("created_at").notNull().defaultNow(),
  },
  (t) => [
    index("idx_saved_keywords_project").on(t.projectId),
    index("idx_saved_keywords_persona").on(t.personaId),
  ],
);

export const scoringProfiles = pgTable(
  "scoring_profiles",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    userId: text("user_id")
      .notNull()
      .references(() => users.id, { onDelete: "cascade" }),
    name: text("name").notNull(),
    isDefault: boolean("is_default").notNull().default(false),
    weights: jsonb("weights")
      .$type<{
        technical: number;
        content: number;
        aiReadiness: number;
        performance: number;
      }>()
      .notNull(),
    disabledFactors: jsonb("disabled_factors").$type<string[]>().default([]),
    createdAt: timestamp("created_at").notNull().defaultNow(),
  },
  (t) => [index("idx_scoring_profiles_user").on(t.userId)],
);

