import { Hono } from "hono";
import type { AppEnv } from "../index";
import { authMiddleware } from "../middleware/auth";
import { personaQueries, userQueries, projectQueries } from "@llm-boost/db";
import { PLAN_LIMITS } from "@llm-boost/shared";
import { handleServiceError } from "../services/errors";

export const personaRoutes = new Hono<AppEnv>();
personaRoutes.use("*", authMiddleware);

// List personas for a project
personaRoutes.get("/:projectId", async (c) => {
  const db = c.get("db");
  const userId = c.get("userId");
  const projectId = c.req.param("projectId");

  const project = await projectQueries(db).getById(projectId);
  if (!project || project.userId !== userId) {
    return c.json(
      { error: { code: "NOT_FOUND", message: "Project not found" } },
      404,
    );
  }

  const personas = await personaQueries(db).listByProject(projectId);
  return c.json({ data: personas });
});

// Create persona (manual or AI-generated)
personaRoutes.post("/:projectId", async (c) => {
  const db = c.get("db");
  const userId = c.get("userId");
  const projectId = c.req.param("projectId");

  try {
    const project = await projectQueries(db).getById(projectId);
    if (!project || project.userId !== userId) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Project not found" } },
        404,
      );
    }

    const user = await userQueries(db).getById(userId);
    const limits = PLAN_LIMITS[user?.plan ?? "free"];
    const count = await personaQueries(db).countByProject(projectId);

    if (count >= limits.personasPerProject) {
      return c.json(
        {
          error: {
            code: "PLAN_LIMIT_REACHED",
            message: `Your plan allows ${limits.personasPerProject} personas per project.`,
          },
        },
        403,
      );
    }

    const body = await c.req.json();
    const persona = await personaQueries(db).create({
      projectId,
      name: body.name,
      role: body.role ?? body.name,
      jobToBeDone: body.jobToBeDone,
      constraints: body.constraints,
      successMetrics: body.successMetrics,
      decisionCriteria: body.decisionCriteria,
      vocabulary: body.vocabulary ?? [],
      sampleQueries: body.sampleQueries ?? [],
      funnelStage: body.funnelStage ?? "education",
      avatarUrl: body.avatarUrl,
      isAutoGenerated: body.isAutoGenerated ?? false,
    });

    return c.json({ data: persona }, 201);
  } catch (error) {
    return handleServiceError(c, error);
  }
});

// Update persona
personaRoutes.patch("/:id", async (c) => {
  const db = c.get("db");
  const userId = c.get("userId");
  const id = c.req.param("id");

  try {
    const persona = await personaQueries(db).getById(id);
    if (!persona) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Persona not found" } },
        404,
      );
    }

    const project = await projectQueries(db).getById(persona.projectId);
    if (!project || project.userId !== userId) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Persona not found" } },
        404,
      );
    }

    const body = await c.req.json();
    const updated = await personaQueries(db).update(id, body);
    return c.json({ data: updated });
  } catch (error) {
    return handleServiceError(c, error);
  }
});

// Delete persona
personaRoutes.delete("/:id", async (c) => {
  const db = c.get("db");
  const userId = c.get("userId");
  const id = c.req.param("id");

  try {
    const persona = await personaQueries(db).getById(id);
    if (!persona) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Persona not found" } },
        404,
      );
    }

    const project = await projectQueries(db).getById(persona.projectId);
    if (!project || project.userId !== userId) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Persona not found" } },
        404,
      );
    }

    await personaQueries(db).remove(id);
    return c.body(null, 204);
  } catch (error) {
    return handleServiceError(c, error);
  }
});

// AI-generate a persona from a role name
personaRoutes.post("/:projectId/generate", async (c) => {
  const db = c.get("db");
  const userId = c.get("userId");
  const projectId = c.req.param("projectId");

  try {
    const user = await userQueries(db).getById(userId);
    const limits = PLAN_LIMITS[user?.plan ?? "free"];
    if (!limits.personaRefinement) {
      return c.json(
        {
          error: {
            code: "PLAN_LIMIT_REACHED",
            message: "AI persona generation requires Starter plan or higher.",
          },
        },
        403,
      );
    }

    const project = await projectQueries(db).getById(projectId);
    if (!project || project.userId !== userId) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Project not found" } },
        404,
      );
    }

    const body = await c.req.json();
    const roleName = body.role;
    if (!roleName) {
      return c.json(
        {
          error: {
            code: "VALIDATION_ERROR",
            message: "role is required",
          },
        },
        422,
      );
    }

    const { default: Anthropic } = await import("@anthropic-ai/sdk");
    const anthropic = new Anthropic({ apiKey: c.env.ANTHROPIC_API_KEY });

    const prompt = `Generate a detailed audience persona for someone with the role "${roleName}" who would be searching for a product/service like this:
Domain: ${project.domain}
Name: ${project.name}

Return ONLY valid JSON with: { "name", "role", "jobToBeDone", "constraints", "successMetrics", "decisionCriteria", "vocabulary": [], "sampleQueries": [], "funnelStage": "education"|"comparison"|"purchase" }`;

    const response = await anthropic.messages.create({
      model: "claude-haiku-4-5-20251001",
      max_tokens: 1024,
      messages: [{ role: "user", content: prompt }],
    });

    const text =
      response.content[0]?.type === "text" ? response.content[0].text : "{}";
    const cleaned = text.replace(/```json\n?|\n?```/g, "").trim();
    const generated = JSON.parse(cleaned);

    return c.json({ data: generated });
  } catch (error) {
    return handleServiceError(c, error);
  }
});

// AI-refine a persona (suggest improvements)
personaRoutes.post("/:id/refine", async (c) => {
  const db = c.get("db");
  const userId = c.get("userId");
  const id = c.req.param("id");

  try {
    const user = await userQueries(db).getById(userId);
    const limits = PLAN_LIMITS[user?.plan ?? "free"];
    if (!limits.personaRefinement) {
      return c.json(
        {
          error: {
            code: "PLAN_LIMIT_REACHED",
            message: "AI persona refinement requires Starter plan or higher.",
          },
        },
        403,
      );
    }

    const persona = await personaQueries(db).getById(id);
    if (!persona) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Persona not found" } },
        404,
      );
    }

    const project = await projectQueries(db).getById(persona.projectId);
    if (!project || project.userId !== userId) {
      return c.json(
        { error: { code: "NOT_FOUND", message: "Persona not found" } },
        404,
      );
    }

    const { default: Anthropic } = await import("@anthropic-ai/sdk");
    const anthropic = new Anthropic({ apiKey: c.env.ANTHROPIC_API_KEY });

    const prompt = `Review this audience persona and suggest specific improvements to make it more useful for AI search tracking:

Current persona:
${JSON.stringify(persona, null, 2)}

For the website: ${project.domain} (${project.name})

Suggest improvements for each field. Focus on:
- More specific job-to-be-done descriptions
- More realistic vocabulary and phrasing patterns
- Better sample queries that someone in this role would actually type into ChatGPT/Perplexity
- Missing constraints or decision criteria

Return ONLY valid JSON with the same structure as the input, with improved values.`;

    const response = await anthropic.messages.create({
      model: "claude-haiku-4-5-20251001",
      max_tokens: 1024,
      messages: [{ role: "user", content: prompt }],
    });

    const text =
      response.content[0]?.type === "text" ? response.content[0].text : "{}";
    const cleaned = text.replace(/```json\n?|\n?```/g, "").trim();
    const suggestions = JSON.parse(cleaned);

    return c.json({ data: suggestions });
  } catch (error) {
    return handleServiceError(c, error);
  }
});
