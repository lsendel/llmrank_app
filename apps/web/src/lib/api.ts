import { normalizeDomain } from "@llm-boost/shared";
import { apiUrl } from "./api-base-url";

// ─── Error handling ─────────────────────────────────────────────────

export interface ComparisonItem {
  url: string;
  oldScore: number | null;
  newScore: number | null;
  delta: number;
}

export class ApiError extends Error {
  constructor(
    public status: number,
    public code: string,
    message: string,
    public details?: Record<string, unknown>,
  ) {
    super(message);
    this.name = "ApiError";
  }
}

// ─── Types ──────────────────────────────────────────────────────────

export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
  };
}

export type ProjectsDefaultPreset =
  | "seo_manager"
  | "content_lead"
  | "exec_summary";

export interface AccountPreferences {
  projectsDefaultPreset: ProjectsDefaultPreset | null;
}

export interface ExtractedFact {
  type: string;
  content: string;
  sourceSentence: string;
  citabilityScore: number;
}

export interface SemanticGapResponse {
  userFacts: ExtractedFact[];
  competitorFacts: ExtractedFact[];
  densityGap: number;
}

export interface Project {
  id: string;
  name: string;
  domain: string;
  createdAt: string;
  updatedAt: string;
  siteDescription?: string | null;
  industry?: string | null;
  settings: {
    maxPages: number;
    maxDepth: number;
    schedule: "manual" | "daily" | "weekly" | "monthly";
    ignoreRobots?: boolean;
    allowHttpFallback?: boolean;
  };
  branding?: {
    logoUrl?: string;
    companyName?: string;
    primaryColor?: string;
  };
  pipelineSettings?: {
    autoRunOnCrawl?: boolean;
    skipSteps?: string[];
  };
  latestCrawl?: CrawlJob | null;
}

export interface CreateProjectInput {
  name: string;
  domain: string;
}

export interface UpdateProjectInput {
  name?: string;
  settings?: {
    maxPages?: number;
    maxDepth?: number;
    schedule?: "manual" | "daily" | "weekly" | "monthly";
    ignoreRobots?: boolean;
    allowHttpFallback?: boolean;
  };
  branding?: {
    logoUrl?: string;
    companyName?: string;
    primaryColor?: string;
  };
}

export interface StrategyPersona {
  name: string;
  role: string;
  demographics: string;
  goals: string[];
  pains: string[];
  keywords: string[];
  typicalQueries: string[];
}

export interface StrategyCompetitor {
  id: string;
  projectId: string;
  domain: string;
  createdAt: string;
}

export interface Persona {
  id: string;
  projectId: string;
  name: string;
  role: string;
  jobToBeDone?: string;
  constraints?: string;
  successMetrics?: string;
  decisionCriteria?: string;
  vocabulary: string[];
  sampleQueries: string[];
  funnelStage: "education" | "comparison" | "purchase";
  avatarUrl?: string;
  isAutoGenerated: boolean;
  createdAt: string;
}

export interface SavedKeyword {
  id: string;
  projectId: string;
  keyword: string;
  source: "auto_discovered" | "user_added" | "perplexity";
  relevanceScore?: number;
  funnelStage?: "education" | "comparison" | "purchase";
  personaId?: string;
  createdAt: string;
}

export interface DiscoveryResult {
  competitors: string[];
  personas: Array<Omit<Persona, "id" | "projectId" | "createdAt">>;
  keywords: Array<{
    keyword: string;
    funnelStage?: string;
    relevanceScore?: number;
  }>;
}

export interface GapAnalysisResult {
  missingElements: string[];
  recommendation: string;
}

export interface CrawlJob {
  id: string;
  projectId: string;
  status: "pending" | "crawling" | "scoring" | "complete" | "failed";
  startedAt: string | null;
  completedAt: string | null;
  pagesFound: number;
  pagesCrawled: number;
  pagesScored: number;
  pagesErrored: number;
  overallScore: number | null;
  letterGrade: string | null;
  scores: {
    technical: number;
    content: number;
    aiReadiness: number;
    performance: number;
  } | null;
  errorMessage: string | null;
  summary: string | null;
  summaryData?: CrawlSummaryData | null;
  createdAt: string;
  projectName?: string;
  projectId2?: string;
}

export interface SiteContext {
  hasLlmsTxt: boolean;
  aiCrawlersBlocked: string[];
  hasSitemap: boolean;
  sitemapAnalysis?: {
    isValid: boolean;
    urlCount: number;
    staleUrlCount: number;
    discoveredPageCount: number;
  };
  contentHashes: Record<string, string>;
  responseTimeMs?: number;
  pageSizeBytes?: number;
}

export interface CrawlSummaryData {
  project: {
    id: string;
    name: string;
    domain: string;
  };
  overallScore: number;
  letterGrade: string;
  categoryScores: {
    technical: number;
    content: number;
    aiReadiness: number;
    performance: number;
  };
  quickWins: QuickWin[];
  pagesScored: number;
  generatedAt: string;
  issueCount: number;
  siteContext?: SiteContext;
}

export interface CrawledPage {
  id: string;
  crawlId: string;
  url: string;
  statusCode: number;
  title: string | null;
  metaDescription: string | null;
  wordCount: number;
  overallScore: number | null;
  technicalScore: number | null;
  contentScore: number | null;
  aiReadinessScore: number | null;
  performanceScore: number | null;
  letterGrade: string | null;
  issueCount: number;
}

export interface PageDetail extends CrawledPage {
  canonicalUrl: string | null;
  extracted: {
    h1: string[];
    h2: string[];
    schemaTypes: string[];
    internalLinks: string[];
    externalLinks: string[];
    imagesWithoutAlt: number;
    hasRobotsMeta: boolean;
  };
  lighthouse: {
    performance: number;
    seo: number;
    accessibility: number;
    bestPractices: number;
  } | null;
  issues: PageIssue[];
}

export interface PageIssue {
  code: string;
  category: "technical" | "content" | "ai_readiness" | "performance";
  severity: "critical" | "warning" | "info";
  message: string;
  recommendation: string;
  data?: Record<string, unknown>;
  pageId?: string;
  pageUrl?: string | null;
}

export interface AIAuditCheck {
  name: string;
  score: number;
  status: "pass" | "warn" | "fail";
}

export interface AIAuditResult {
  checks: AIAuditCheck[];
  issueCount: number;
  criticalCount: number;
  pagesAudited: number;
}

export interface VisibilityCheck {
  id: string;
  projectId: string;
  pageId?: string;
  llmProvider:
    | "chatgpt"
    | "claude"
    | "perplexity"
    | "gemini"
    | "copilot"
    | "gemini_ai_mode"
    | "grok";
  query: string;
  keywordId?: string | null;
  responseText: string | null;
  brandMentioned: boolean;
  urlCited: boolean;
  citationPosition: number | null;
  competitorMentions:
    | {
        domain: string;
        mentioned: boolean;
        position: number | null;
      }[]
    | null;
  checkedAt: string;
}

export interface PageScoreEntry {
  id: string;
  pageId: string;
  url: string;
  title: string | null;
  statusCode: number | null;
  wordCount: number | null;
  overallScore: number;
  technicalScore: number | null;
  contentScore: number | null;
  aiReadinessScore: number | null;
  lighthousePerf: number | null;
  lighthouseSeo: number | null;
  letterGrade: string;
  detail: Record<string, unknown> | null;
}

export interface PageScoreDetail {
  id: string;
  jobId: string;
  url: string;
  canonicalUrl: string | null;
  statusCode: number | null;
  title: string | null;
  metaDesc: string | null;
  wordCount: number | null;
  contentType?: string | null;
  textLength?: number | null;
  htmlLength?: number | null;
  contentHash: string | null;
  crawledAt: string | null;
  score: {
    overallScore: number;
    technicalScore: number | null;
    contentScore: number | null;
    aiReadinessScore: number | null;
    lighthousePerf: number | null;
    lighthouseSeo: number | null;
    letterGrade: string;
    detail: Record<string, unknown>;
    platformScores: Record<
      string,
      {
        score: number;
        grade: string;
        tips: string[];
      }
    > | null;
    recommendations: Array<{
      issueCode: string;
      title: string;
      description: string;
      priority: string;
      effort: string;
      impact: string;
      estimatedImprovement: number;
      affectedPlatforms: string[];
      steps?: string[];
      example?: { before: string; after: string };
    }> | null;
  } | null;
  issues: PageIssue[];
}

export interface NotificationPreferences {
  notifyOnCrawlComplete: boolean;
  notifyOnScoreDrop: boolean;
  webhookUrl: string | null;
}

export interface DigestPreferences {
  digestFrequency: string;
  digestDay: number;
  lastDigestSentAt: string | null;
}

export interface ShareInfo {
  shareToken: string;
  shareUrl: string;
  badgeUrl: string;
  level: "summary" | "issues" | "full";
  expiresAt: string | null;
}

export interface RecommendationConfidence {
  label: "High" | "Medium" | "Low";
  variant: "success" | "warning" | "destructive";
  score?: number;
}

export interface PublicReport {
  shareLevel: string;
  crawlId: string;
  projectId: string;
  completedAt: string;
  pagesScored: number;
  pagesCrawled?: number;
  summary: string | null;
  summaryData: {
    overallScore: number;
    letterGrade: string;
    categoryScores: {
      technical: number;
      content: number;
      aiReadiness: number;
      performance: number;
    };
    quickWins: unknown[];
  } | null;
  project: { name: string; domain: string; branding: unknown };
  scores: {
    overall: number;
    technical: number;
    content: number;
    aiReadiness: number;
    performance: number;
    letterGrade: string;
  };
  pages: Array<{
    url: string;
    title: string;
    overallScore: number;
    technicalScore: number;
    contentScore: number;
    aiReadinessScore: number;
    issueCount: number;
  }>;
  issueCount: number;
  readinessCoverage: Record<string, number>;
  scoreDeltas: Record<string, number> | null;
  quickWins: Array<{
    code: string;
    category: string;
    severity: string;
    scoreImpact: number;
    effortLevel: string;
    message: string;
    recommendation: string;
    affectedPages: number;
    dataTimestamp?: string | null;
    confidence?: RecommendationConfidence;
  }>;
}

export interface BillingInfo {
  plan: "free" | "starter" | "pro" | "agency";
  crawlCreditsRemaining: number;
  crawlCreditsTotal: number;
  maxPagesPerCrawl: number;
  maxDepth: number;
  maxProjects: number;
}

export interface SubscriptionInfo {
  id: string;
  planCode: string;
  status: "active" | "trialing" | "past_due" | "canceled";
  currentPeriodEnd: string | null;
  cancelAtPeriodEnd: boolean;
  canceledAt: string | null;
}

export interface PaymentRecord {
  id: string;
  amountCents: number;
  currency: string;
  status: "succeeded" | "pending" | "failed";
  stripeInvoiceId: string;
  createdAt: string;
}

export interface PromoInfo {
  code: string;
  discountType: "percent_off" | "amount_off" | "free_months";
  discountValue: number;
  duration: "once" | "repeating" | "forever";
  durationMonths: number | null;
}

export interface Promo {
  id: string;
  code: string;
  stripeCouponId: string;
  discountType: "percent_off" | "amount_off" | "free_months";
  discountValue: number;
  duration: "once" | "repeating" | "forever";
  durationMonths: number | null;
  maxRedemptions: number | null;
  timesRedeemed: number;
  expiresAt: string | null;
  active: boolean;
  createdAt: string;
}

export interface BlockedDomain {
  id: string;
  domain: string;
  reason: string | null;
  blockedBy: string;
  createdAt: string;
}

export interface AdminStats {
  mrr: number;
  mrrByPlan: Record<string, number>;
  totalRevenue: number;
  failedPayments: number;
  activeSubscribers: number;
  totalCustomers: number;
  churnRate: number;
  ingestHealth: {
    pendingJobs: number;
    runningJobs: number;
    failedLast24h: number;
    avgCompletionMinutes: number;
    outboxPending: number;
  };
}

export interface CrawlJobSummary {
  id: string;
  projectId: string;
  projectName: string | null;
  status: string;
  createdAt: string;
  startedAt: string | null;
  completedAt: string | null;
  pagesFound?: number;
  pagesCrawled?: number;
  pagesScored?: number;
  errorMessage: string | null;
  cancelledAt?: string | null;
  cancelledBy?: string | null;
  cancelReason?: string | null;
}

export interface OutboxEventSummary {
  id: string;
  type: string;
  attempts: number;
  availableAt: string;
  createdAt: string;
}

export interface AdminIngestDetails {
  pendingJobs: CrawlJobSummary[];
  runningJobs: CrawlJobSummary[];
  failedJobs: CrawlJobSummary[];
  outboxEvents: OutboxEventSummary[];
}

export interface AdminCustomer {
  id: string;
  email: string;
  name: string | null;
  plan: string;
  stripeCustomerId: string | null;
  createdAt: string;
}

export interface AdminCustomerDetail {
  user: AdminCustomer;
  subscriptions: SubscriptionInfo[];
  payments: PaymentRecord[];
}

export interface QuickWin {
  code: string;
  category: string;
  severity: string;
  scoreImpact: number;
  effortLevel: "low" | "medium" | "high";
  message: string;
  recommendation: string;
  implementationSnippet?: string;
  priority: number;
  affectedPages: number;
  owner?: string;
  pillar?: string;
  docsUrl?: string;
  effort?: "low" | "medium" | "high";
  dataTimestamp?: string | null;
  confidence?: RecommendationConfidence;
}

export interface PublicScanResult {
  id?: string;
  scanResultId?: string;
  url: string;
  domain: string;
  createdAt?: string;
  scores: {
    overall: number;
    technical: number;
    content: number;
    aiReadiness: number;
    performance: number;
    letterGrade: string;
  };
  issues: PageIssue[];
  quickWins?: QuickWin[];
  meta?: {
    title: string | null;
    description: string | null;
    wordCount: number;
    hasLlmsTxt: boolean;
    hasSitemap: boolean;
    sitemapUrls: number;
    aiCrawlersBlocked: string[];
    schemaTypes: string[];
    ogTags: Record<string, string>;
    siteContext?: SiteContext;
  };
  siteContext?: SiteContext;
  visibility?:
    | {
        provider: string;
        brandMentioned: boolean;
        urlCited: boolean;
        citationPosition?: number | null;
        competitorMentions?:
          | {
              domain: string;
              mentioned: boolean;
              position: number | null;
            }[]
          | null;
      }[]
    | {
        provider: string;
        brandMentioned: boolean;
        urlCited: boolean;
      }
    | null;
}

export interface IntegrationCatalogItem {
  id: string;
  provider: "gsc" | "ga4" | null;
  name: string;
  description: string;
  features: string[];
  availability: "available_now" | "coming_soon";
  access: "public" | "requires_auth";
  minPlan: "pro" | "agency" | null;
  authType: "oauth2" | "api_key";
  link?: string;
}

export interface SharedReport {
  crawlId: string;
  projectId: string;
  completedAt: string | null;
  pagesScored: number;
  pagesCrawled?: number;
  summary: string | null;
  summaryData?: unknown;
  project: {
    name: string;
    domain: string;
    branding?: {
      logoUrl?: string;
      companyName?: string;
      primaryColor?: string;
    };
  };
  scores: {
    overall: number;
    technical: number;
    content: number;
    aiReadiness: number;
    performance: number;
    letterGrade: string;
  };
  pages: {
    url: string;
    title: string | null;
    overallScore: number;
    technicalScore: number | null;
    contentScore: number | null;
    aiReadinessScore: number | null;
    issueCount: number;
  }[];
  issueCount: number;
  quickWins: QuickWin[];
  readinessCoverage: DashboardCoverageMetric[];
  scoreDeltas: DashboardScoreDeltas;
}

export interface PlatformReadinessResult {
  platform: string;
  score: number;
  grade: string;
  tips: string[];
  checks: {
    factor: string;
    label: string;
    importance: "critical" | "important" | "recommended";
    pass: boolean;
  }[];
}

export interface VisibilityTrend {
  weekStart: string;
  provider: string;
  mentionRate: number;
  citationRate: number;
  totalChecks: number;
}

export interface VisibilityGap {
  query: string;
  providers: string[];
  userMentioned: boolean;
  userCited: boolean;
  competitorsCited: Array<{
    domain: string;
    position: number | null;
  }>;
}

export interface CitedPage {
  citedUrl: string;
  citationCount: number;
  providers: string[];
  avgPosition: number;
  lastCited: string;
}

export interface BrandSentiment {
  overallSentiment: "positive" | "neutral" | "negative" | "mixed" | null;
  sentimentScore: number | null;
  distribution: { positive: number; neutral: number; negative: number };
  recentDescriptions: {
    description: string;
    provider: string;
    checkedAt: string | Date;
  }[];
  providerBreakdown: Record<
    string,
    { positive: number; neutral: number; negative: number; total: number }
  >;
  sampleSize: number;
}

export interface BrandSentimentSnapshot {
  id: string;
  projectId: string;
  period: string;
  overallSentiment: "positive" | "neutral" | "negative" | "mixed" | null;
  sentimentScore: number | null;
  keyAttributes: unknown;
  brandNarrative: string | null;
  strengthTopics: unknown;
  weaknessTopics: unknown;
  providerBreakdown: unknown;
  sampleSize: number;
  createdAt: string | Date;
}

export interface BrandPerceptionProvider {
  provider: string;
  sampleSize: number;
  overallSentiment: "positive" | "neutral" | "negative";
  sentimentScore: number;
  distribution: { positive: number; neutral: number; negative: number };
  descriptions: string[];
}

export interface BrandPerformance {
  period: string;
  yourBrand: {
    mentionRate: number;
    citationRate: number;
    sovPercent: number;
    trend: number;
  };
  competitors: {
    domain: string;
    mentionRate: number;
    citationRate: number;
    sovPercent: number;
    trend: number;
  }[];
  topPrompts: {
    query: string;
    yourMentioned: boolean;
    competitorsMentioned: string[];
  }[];
  weekOverWeek: {
    mentionsDelta: number;
    sovDelta: number;
    citationsDelta: number;
  };
}

export interface SourceOpportunity {
  domain: string;
  mentionCount: number;
  queries: string[];
}

export interface AIPrompt {
  id: string;
  projectId: string;
  prompt: string;
  category: string | null;
  estimatedVolume: number | null;
  difficulty: number | null;
  intent: string | null;
  yourMentioned: boolean | null;
  competitorsMentioned: unknown;
  source: string;
  discoveredAt: string;
}

export interface PromptCheckResult {
  promptId?: string;
  prompt: string;
  checkCount: number;
  yourMentioned: boolean;
  competitorsMentioned: string[];
  checks: VisibilityCheck[];
}

export interface AIScoreTrend {
  current: {
    overall: number;
    grade: "A" | "B" | "C" | "D" | "F";
    breakdown: {
      llmMentions: number;
      aiSearch: number;
      shareOfVoice: number;
      backlinkAuthority: number;
    };
  };
  previous: {
    overall: number;
    grade: "A" | "B" | "C" | "D" | "F";
    breakdown: {
      llmMentions: number;
      aiSearch: number;
      shareOfVoice: number;
      backlinkAuthority: number;
    };
  } | null;
  delta: number;
  direction: "up" | "down" | "stable";
  period: string;
  meta: {
    currentChecks: number;
    previousChecks: number;
    referringDomains: number;
    estimatedMonthlyAudience: number;
    audienceGrowth: number;
  };
}

export interface VisibilityRecommendation {
  type: "gap" | "platform" | "issue" | "trend" | "coverage";
  title: string;
  description: string;
  impact: "high" | "medium" | "low";
  provider?: string;
  fixUrl?: string;
}

export interface ScheduledQuery {
  id: string;
  projectId: string;
  query: string;
  providers: string[];
  frequency: "hourly" | "daily" | "weekly";
  enabled: boolean;
  lastRunAt: string | null;
  nextRunAt: string;
  createdAt: string;
}

export interface CreateScheduleInput {
  projectId: string;
  query: string;
  providers: string[];
  frequency: "hourly" | "daily" | "weekly";
}

export interface ScheduleUpdate {
  query: string;
  providers: string[];
  frequency: "hourly" | "daily" | "weekly";
  enabled: boolean;
}

export interface LogUpload {
  id: string;
  projectId: string;
  filename: string;
  totalRequests: number;
  crawlerRequests: number;
  uniqueIPs: number;
  summary: LogAnalysisSummary;
  createdAt: string;
}

export interface LogAnalysisSummary {
  totalRequests: number;
  crawlerRequests: number;
  uniqueIPs: number;
  botBreakdown: Array<{ bot: string; count: number }>;
  statusBreakdown: Array<{ status: number; count: number }>;
  topPaths: Array<{ path: string; count: number }>;
}

export interface CrawlInsights {
  issueDistribution: {
    bySeverity: { severity: string; count: number }[];
    byCategory: { category: string; count: number }[];
    total: number;
  };
  scoreRadar: {
    technical: number;
    content: number;
    aiReadiness: number;
    performance: number;
  };
  gradeDistribution: {
    grade: string;
    count: number;
    percentage: number;
  }[];
  contentRatio: {
    avgWordCount: number;
    avgHtmlToTextRatio: number;
    pagesAboveThreshold: number;
    totalPages: number;
    totalTextLength: number;
    totalHtmlLength: number;
  };
  crawlProgress: {
    found: number;
    crawled: number;
    scored: number;
    errored: number;
    status: string;
  };
}

export interface IssueHeatmapData {
  categories: string[];
  pages: {
    url: string;
    pageId: string;
    issues: Record<string, string>;
  }[];
}

export interface CrawlerTimelinePoint {
  timestamp: string;
  gptbot: number;
  claudebot: number;
  perplexitybot: number;
  googlebot: number;
  bingbot: number;
  other: number;
}

export interface Report {
  id: string;
  projectId: string;
  crawlJobId: string;
  type: "summary" | "detailed";
  format: "pdf" | "docx";
  status: "queued" | "generating" | "complete" | "failed";
  r2Key: string | null;
  fileSize: number | null;
  config: Record<string, unknown>;
  error: string | null;
  generatedAt: string | null;
  expiresAt: string | null;
  createdAt: string;
}

export interface ReportSchedule {
  id: string;
  projectId: string;
  format: "pdf" | "docx";
  type: "summary" | "detailed";
  recipientEmail: string;
  enabled: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface ProjectIntegration {
  id: string;
  projectId: string;
  provider: "gsc" | "psi" | "ga4" | "clarity";
  enabled: boolean;
  hasCredentials: boolean;
  config: Record<string, unknown>;
  tokenExpiresAt: string | null;
  lastSyncAt: string | null;
  lastError: string | null;
  createdAt: string;
  updatedAt: string;
}

export interface IntegrationInsights {
  crawlId: string | null;
  integrations: {
    gsc: {
      topQueries: {
        query: string;
        impressions: number;
        clicks: number;
        position: number;
      }[];
      totalClicks: number;
      totalImpressions: number;
      indexedPages: { url: string; status: string }[];
    } | null;
    ga4: {
      bounceRate: number;
      avgEngagement: number;
      topPages: { url: string; sessions: number }[];
    } | null;
    clarity: {
      avgUxScore: number;
      rageClickPages: string[];
    } | null;
  } | null;
}

export interface PageEnrichment {
  id: string;
  pageId: string;
  jobId: string;
  provider: "gsc" | "psi" | "ga4" | "clarity";
  data: Record<string, unknown>;
  fetchedAt: string;
}

export interface DashboardStats {
  totalProjects: number;
  totalCrawls: number;
  avgScore: number;
  creditsRemaining: number;
  creditsTotal: number;
  latestInsights: DashboardInsightSummary | null;
}

export interface DashboardInsightSummary {
  quickWins: DashboardQuickWin[];
  coverage: DashboardCoverageMetric[];
  scoreDeltas: DashboardScoreDeltas;
}

export interface DashboardScoreDeltas {
  overall: number;
  technical: number;
  content: number;
  aiReadiness: number;
  performance: number;
}

export interface DashboardQuickWin {
  code: string;
  message: string;
  recommendation: string;
  pillar: string;
  owner: string;
  effort: string;
  scoreImpact: number;
  affectedPages: number;
}

export interface DashboardCoverageMetric {
  code: string;
  label: string;
  description: string;
  pillar: string;
  coveragePercent: number;
  affectedPages: number;
  totalPages: number;
}

export interface DashboardActivity extends CrawlJob {
  projectName: string;
  projectId: string;
}

export interface PortfolioPriorityItem {
  id: string;
  projectId: string;
  projectName: string;
  projectDomain: string;
  priority: "critical" | "high" | "medium" | "low";
  category: "onboarding" | "issues" | "crawl" | "keywords" | "competitors";
  channel: "google" | "llm" | "both";
  title: string;
  description: string;
  reason: string;
  action: string;
  owner: string | null;
  dueDate: string;
  expectedImpact: "high" | "medium" | "low";
  impactScore: number;
  trendDelta: number;
  effort: "low" | "medium" | "high";
  freshness: {
    generatedAt: string;
    lastCrawlAt: string | null;
  };
  source: {
    signals: string[];
    confidence: number;
  };
}

// Progress tracking
export interface CategoryDelta {
  current: number;
  previous: number;
  delta: number;
}

export interface ChecklistData {
  visibilityCount: number;
  personaCount: number;
  reportCount: number;
  scheduleCount: number;
}

export interface ProjectProgress {
  currentCrawlId: string;
  previousCrawlId: string;
  scoreDelta: number;
  currentScore: number;
  previousScore: number;
  categoryDeltas: {
    technical: CategoryDelta;
    content: CategoryDelta;
    aiReadiness: CategoryDelta;
    performance: CategoryDelta;
  };
  issuesFixed: number;
  issuesNew: number;
  issuesPersisting: number;
  gradeChanges: { improved: number; regressed: number; unchanged: number };
  velocity: number;
  topImprovedPages: { url: string; delta: number; current: number }[];
  topRegressedPages: { url: string; delta: number; current: number }[];
}

// Regressions
export interface Regression {
  category: string;
  previousScore: number;
  currentScore: number;
  delta: number;
  severity: "critical" | "warning" | "info";
}

// Intelligence fusion
export interface PlatformOpportunity {
  platform: string;
  currentScore: number;
  opportunityScore: number;
  topTips: string[];
  visibilityRate: number | null;
}

export interface FusedInsights {
  aiVisibilityReadiness: number;
  platformOpportunities: PlatformOpportunity[];
  contentHealthMatrix: {
    scoring: number;
    llmQuality: number | null;
    engagement: number | null;
    uxQuality: number | null;
  };
  roiQuickWins: {
    issueCode: string;
    scoreImpact: number;
    estimatedTrafficImpact: number | null;
    effort: "low" | "medium" | "high";
    affectedPages: number;
  }[];
}

// ─── Notification Channels ──────────────────────────────────────────

export type NotificationChannelType = "email" | "webhook" | "slack_incoming";

export type NotificationEventType =
  | "crawl_completed"
  | "score_drop"
  | "mention_gained"
  | "mention_lost"
  | "position_changed";

export interface NotificationChannel {
  id: string;
  userId: string;
  type: NotificationChannelType;
  config: Record<string, string>;
  eventTypes: NotificationEventType[];
  enabled: boolean;
  createdAt: string;
  updatedAt: string;
}

export interface CreateChannelInput {
  type: NotificationChannelType;
  config: Record<string, string>;
  eventTypes: NotificationEventType[];
}

export interface ChannelUpdate {
  enabled: boolean;
  config: Record<string, string>;
  eventTypes: NotificationEventType[];
}

// ─── API Tokens ────────────────────────────────────────────────────

export interface ApiTokenInfo {
  id: string;
  name: string;
  prefix: string;
  type: string;
  scopes: string[];
  projectId: string | null;
  lastUsedAt: string | null;
  createdAt: string;
  expiresAt: string | null;
}

export interface ApiTokenWithPlaintext extends ApiTokenInfo {
  plaintext: string;
}

export interface CreateTokenInput {
  name: string;
  type?: "api" | "mcp";
  projectId?: string;
  scopes?: string[];
}

export interface ScoringProfile {
  id: string;
  name: string;
  weights: {
    technical: number;
    content: number;
    aiReadiness: number;
    performance: number;
  };
  disabledFactors: string[];
  isDefault: boolean;
  createdAt: string;
}

export interface Team {
  id: string;
  name: string;
  ownerId: string;
  plan: string;
  role: string;
  createdAt: string;
}

export interface TeamMember {
  id: string;
  teamId: string;
  userId: string;
  name: string | null;
  email: string;
  role: string;
  joinedAt: string;
  _debug?: boolean;
}

export interface TeamDetail extends Omit<Team, "role"> {
  members: TeamMember[];
  role: string;
}

export interface Organization {
  id: string;
  name: string;
  slug: string;
  createdAt: string;
}

export interface OrganizationMember {
  id: string;
  userId: string;
  name: string | null;
  email: string;
  role: "owner" | "admin" | "member" | "viewer";
  joinedAt: string;
}

export interface OrganizationInvite {
  id: string;
  email: string;
  role: "admin" | "member" | "viewer";
  status: "pending" | "accepted" | "expired";
  expiresAt: string;
  createdAt: string;
}

export interface Benchmarks {
  p10: number;
  p25: number;
  p50: number;
  p75: number;
  p90: number;
  count: number;
  updatedAt: string;
}

// ─── Action Items ───────────────────────────────────────────────────

export type ActionItemStatus =
  | "pending"
  | "in_progress"
  | "fixed"
  | "dismissed";

export interface ActionItem {
  id: string;
  projectId: string;
  issueCode: string;
  status: ActionItemStatus;
  severity: "critical" | "warning" | "info";
  category: string;
  scoreImpact: number;
  title: string;
  description: string | null;
  assigneeId: string | null;
  dueAt: string | null;
  verifiedAt: string | null;
  verifiedByCrawlId: string | null;
  createdAt: string;
  updatedAt: string;
}

export interface ActionItemStats {
  total: number;
  fixed: number;
  inProgress: number;
  dismissed: number;
  pending: number;
  fixRate: number;
}

export interface PipelineRecommendation {
  priority: "critical" | "high" | "medium" | "low";
  category: string;
  title: string;
  description: string;
  action?: string;
}

export type PipelineRunStatus =
  | "pending"
  | "running"
  | "paused"
  | "completed"
  | "failed";

export interface PipelineRun {
  id: string;
  status: PipelineRunStatus;
  currentStep: string | null;
  stepResults: Record<string, unknown> | null;
  startedAt: string | null;
  completedAt: string | null;
  createdAt: string;
}

export interface PipelineHealthCheck {
  check: string;
  category: "technical" | "configuration" | "billing";
  status: "pass" | "warn" | "fail";
  message: string;
  autoFixable: boolean;
  suggestion?: string;
}

export interface PipelineHealthCheckResult {
  projectId: string;
  crawlJobId: string;
  checks: PipelineHealthCheck[];
  score: number;
}

// ─── Request helpers ────────────────────────────────────────────────

interface RequestOptions extends Omit<RequestInit, "body"> {
  body?: unknown;
}

async function request<T>(
  path: string,
  options: RequestOptions = {},
): Promise<T> {
  const { body, headers: extraHeaders, ...init } = options;

  const headers = new Headers(extraHeaders);
  headers.set("Content-Type", "application/json");

  try {
    const response = await fetch(apiUrl(path), {
      ...init,
      headers,
      credentials: "include",
      body: body ? JSON.stringify(body) : undefined,
    });

    if (!response.ok) {
      const errorBody = await response.json().catch(() => null);
      throw new ApiError(
        response.status,
        errorBody?.error?.code ?? "UNKNOWN_ERROR",
        errorBody?.error?.message ?? response.statusText,
        errorBody?.error?.details,
      );
    }

    // Handle 204 No Content
    if (response.status === 204) {
      return undefined as T;
    }

    try {
      return (await response.json()) as T;
    } catch {
      throw new ApiError(
        response.status,
        "INVALID_RESPONSE",
        "Invalid JSON response from server",
      );
    }
  } catch (error) {
    if (error instanceof ApiError) {
      throw error;
    }
    // Handle network errors (fetch throws)
    throw new ApiError(
      0,
      "NETWORK_ERROR",
      error instanceof Error ? error.message : "Network request failed",
    );
  }
}

// ─── Envelope unwrapper ─────────────────────────────────────────────

interface ApiEnvelope<T> {
  data: T;
}

// ─── Base client ────────────────────────────────────────────────────

const apiClient = {
  get<T>(path: string, options?: RequestOptions): Promise<T> {
    return request<T>(path, { ...options, method: "GET" });
  },

  post<T>(path: string, body?: unknown, options?: RequestOptions): Promise<T> {
    return request<T>(path, { ...options, method: "POST", body });
  },

  put<T>(path: string, body?: unknown, options?: RequestOptions): Promise<T> {
    return request<T>(path, { ...options, method: "PUT", body });
  },

  delete<T>(path: string, options?: RequestOptions): Promise<T> {
    return request<T>(path, { ...options, method: "DELETE" });
  },

  patch<T>(path: string, body?: unknown, options?: RequestOptions): Promise<T> {
    return request<T>(path, { ...options, method: "PATCH", body });
  },
};

// ─── Query string helper ────────────────────────────────────────────

function buildQueryString(
  params?: Record<string, string | number | undefined>,
): string {
  if (!params) return "";
  const searchParams = new URLSearchParams();
  for (const [key, value] of Object.entries(params)) {
    if (value !== undefined) {
      searchParams.set(key, String(value));
    }
  }
  const qs = searchParams.toString();
  return qs ? `?${qs}` : "";
}

function extractFilename(contentDisposition: string | null): string | null {
  if (!contentDisposition) return null;
  const match = contentDisposition.match(/filename="?([^";]+)"?/i);
  return match?.[1] ?? null;
}

async function postDownload(path: string): Promise<{
  filename: string | null;
  contentType: string | null;
  content: string;
}> {
  const response = await fetch(apiUrl(path), {
    method: "POST",
    credentials: "include",
    headers: { Accept: "*/*" },
  });

  if (!response.ok) {
    const errorBody = await response.json().catch(() => null);
    throw new ApiError(
      response.status,
      errorBody?.error?.code ?? "UNKNOWN_ERROR",
      errorBody?.error?.message ?? response.statusText,
      errorBody?.error?.details,
    );
  }

  return {
    filename: extractFilename(response.headers.get("content-disposition")),
    contentType: response.headers.get("content-type"),
    content: await response.text(),
  };
}

// ─── Domain-specific API methods ────────────────────────────────────

export const api = {
  // ── Dashboard ───────────────────────────────────────────────────
  dashboard: {
    async getStats(): Promise<DashboardStats> {
      const res = await apiClient.get<ApiEnvelope<DashboardStats>>(
        "/api/dashboard/stats",
      );
      return res.data;
    },
    async getRecentActivity(): Promise<DashboardActivity[]> {
      const res = await apiClient.get<ApiEnvelope<DashboardActivity[]>>(
        "/api/dashboard/activity",
      );
      return res.data;
    },
    async getPriorityFeed(limit = 15): Promise<PortfolioPriorityItem[]> {
      const qs = buildQueryString({ limit });
      const res = await apiClient.get<ApiEnvelope<PortfolioPriorityItem[]>>(
        `/api/dashboard/priority-feed${qs}`,
      );
      return res.data;
    },
  },

  // ── Projects ────────────────────────────────────────────────────
  projects: {
    async list(params?: {
      page?: number;
      limit?: number;
      q?: string;
      health?:
        | "all"
        | "good"
        | "needs_work"
        | "poor"
        | "no_crawl"
        | "in_progress"
        | "failed";
      sort?:
        | "activity_desc"
        | "score_desc"
        | "score_asc"
        | "name_asc"
        | "name_desc"
        | "created_desc"
        | "created_asc";
    }): Promise<PaginatedResponse<Project>> {
      const qs = buildQueryString(params);
      return apiClient.get<PaginatedResponse<Project>>(`/api/projects${qs}`);
    },

    async get(projectId: string): Promise<Project> {
      const res = await apiClient.get<ApiEnvelope<Project>>(
        `/api/projects/${projectId}`,
      );
      return res.data;
    },

    async create(data: CreateProjectInput): Promise<Project> {
      const res = await apiClient.post<ApiEnvelope<Project>>(
        "/api/projects",
        data,
      );
      return res.data;
    },

    async update(
      projectId: string,
      data: UpdateProjectInput,
    ): Promise<Project> {
      const res = await apiClient.put<ApiEnvelope<Project>>(
        `/api/projects/${projectId}`,
        data,
      );
      return res.data;
    },

    async delete(projectId: string): Promise<void> {
      await apiClient.delete<ApiEnvelope<{ id: string; deleted: boolean }>>(
        `/api/projects/${projectId}`,
      );
    },

    async progress(projectId: string): Promise<ProjectProgress | null> {
      const res = await apiClient.get<ApiEnvelope<ProjectProgress | null>>(
        `/api/projects/${projectId}/progress`,
      );
      return res.data;
    },

    async getChecklistStatus(projectId: string): Promise<ChecklistData> {
      const res = await apiClient.get<ApiEnvelope<ChecklistData>>(
        `/api/projects/${projectId}/checklist-status`,
      );
      return res.data;
    },

    async updateSiteContext(
      projectId: string,
      data: { siteDescription?: string; industry?: string },
    ): Promise<void> {
      await apiClient.patch(`/api/projects/${projectId}/site-context`, data);
    },

    async rerunAutoGeneration(
      projectId: string,
    ): Promise<{ pipelineRunId?: string; status?: string }> {
      const res = await apiClient.post<
        ApiEnvelope<{ pipelineRunId?: string; status?: string }>
      >(`/api/projects/${projectId}/rerun-auto-generation`, {});
      return res.data;
    },

    async rediscoverCompetitors(projectId: string): Promise<void> {
      await apiClient.post(
        `/api/projects/${projectId}/rediscover-competitors`,
        {},
      );
    },
  },

  // ── Crawls ──────────────────────────────────────────────────────
  crawls: {
    async start(projectId: string): Promise<CrawlJob> {
      const res = await apiClient.post<ApiEnvelope<CrawlJob>>("/api/crawls", {
        projectId,
      });
      return res.data;
    },

    async getHistory(
      page: number = 1,
      limit: number = 50,
    ): Promise<PaginatedResponse<CrawlJob>> {
      const qs = buildQueryString({ page, limit });
      return apiClient.get<PaginatedResponse<CrawlJob>>(
        `/api/crawls/history${qs}`,
      );
    },

    async deleteHistory(projectId?: string): Promise<{ deleted: number }> {
      const qs = projectId ? `?projectId=${projectId}` : "";
      const res = await apiClient.delete<ApiEnvelope<{ deleted: number }>>(
        `/api/crawls/history${qs}`,
      );
      return res.data;
    },

    async list(
      projectId: string,
      params?: { page?: number; limit?: number },
    ): Promise<PaginatedResponse<CrawlJob>> {
      const qs = buildQueryString(params);
      return apiClient.get<PaginatedResponse<CrawlJob>>(
        `/api/crawls/project/${projectId}${qs}`,
      );
    },

    async get(crawlId: string): Promise<CrawlJob> {
      const res = await apiClient.get<ApiEnvelope<CrawlJob>>(
        `/api/crawls/${crawlId}`,
      );
      return res.data;
    },

    async getInsights(crawlId: string): Promise<CrawlInsights> {
      const res = await apiClient.get<ApiEnvelope<CrawlInsights>>(
        `/api/crawls/${crawlId}/insights`,
      );
      return res.data;
    },

    async getAIAudit(crawlId: string): Promise<AIAuditResult> {
      const res = await apiClient.get<ApiEnvelope<AIAuditResult>>(
        `/api/crawls/${crawlId}/ai-audit`,
      );
      return res.data;
    },

    async exportData(
      crawlId: string,
      format: "csv" | "json",
    ): Promise<string | unknown[]> {
      if (format === "csv") {
        // For CSV, we need the raw response
        const res = await fetch(
          apiUrl(`/api/crawls/${crawlId}/export?format=csv`),
          {
            headers: { Accept: "text/csv" },
            credentials: "include",
          },
        );
        if (!res.ok)
          throw new ApiError(res.status, "EXPORT_FAILED", "Export failed");
        return res.text();
      }
      const res = await apiClient.get<ApiEnvelope<unknown[]>>(
        `/api/crawls/${crawlId}/export?format=json`,
      );
      return res.data;
    },

    async getIssueHeatmap(crawlId: string): Promise<IssueHeatmapData> {
      const res = await apiClient.get<ApiEnvelope<IssueHeatmapData>>(
        `/api/crawls/${crawlId}/issue-heatmap`,
      );
      return res.data;
    },

    async fusedInsights(crawlId: string): Promise<FusedInsights> {
      const res = await apiClient.get<ApiEnvelope<FusedInsights>>(
        `/api/crawls/${crawlId}/fused-insights`,
      );
      return res.data;
    },

    async getProjectHistory(
      projectId: string,
      limit: number = 50,
    ): Promise<ApiEnvelope<CrawlJob[]>> {
      return apiClient.get<ApiEnvelope<CrawlJob[]>>(
        `/api/crawls/project/${projectId}/history?limit=${limit}`,
      );
    },

    async compare(
      crawlId: string,
      otherId: string,
    ): Promise<ApiEnvelope<ComparisonItem[]>> {
      return apiClient.get<ApiEnvelope<ComparisonItem[]>>(
        `/api/crawls/${crawlId}/compare/${otherId}`,
      );
    },
  },

  // ── Pages ───────────────────────────────────────────────────────
  pages: {
    async list(
      crawlId: string,
      params?: {
        page?: number;
        limit?: number;
        sort?: string;
        order?: string;
      },
    ): Promise<PaginatedResponse<CrawledPage>> {
      const qs = buildQueryString(params);
      return apiClient.get<PaginatedResponse<CrawledPage>>(
        `/api/pages/job/${crawlId}${qs}`,
      );
    },

    async get(pageId: string): Promise<PageDetail> {
      const res = await apiClient.get<ApiEnvelope<PageDetail>>(
        `/api/pages/${pageId}`,
      );
      return res.data;
    },

    async getEnrichments(pageId: string): Promise<PageEnrichment[]> {
      const res = await apiClient.get<ApiEnvelope<PageEnrichment[]>>(
        `/api/pages/${pageId}/enrichments`,
      );
      return res.data;
    },
  },

  // ── Issues ──────────────────────────────────────────────────────
  issues: {
    async listForCrawl(
      crawlId: string,
      params?: {
        page?: number;
        limit?: number;
        severity?: string;
        category?: string;
      },
    ): Promise<PaginatedResponse<PageIssue>> {
      const qs = buildQueryString(params);
      return apiClient.get<PaginatedResponse<PageIssue>>(
        `/api/pages/issues/job/${crawlId}${qs}`,
      );
    },
  },

  // ── Billing ─────────────────────────────────────────────────────
  billing: {
    async getInfo(): Promise<BillingInfo> {
      const res =
        await apiClient.get<ApiEnvelope<BillingInfo>>("/api/billing/usage");
      return res.data;
    },

    async createCheckoutSession(
      plan: string,
      successUrl: string,
      cancelUrl: string,
    ): Promise<{ sessionId: string; url: string }> {
      const res = await apiClient.post<
        ApiEnvelope<{ sessionId: string; url: string }>
      >("/api/billing/checkout", { plan, successUrl, cancelUrl });
      return res.data;
    },

    async createPortalSession(returnUrl: string): Promise<{ url: string }> {
      const res = await apiClient.post<ApiEnvelope<{ url: string }>>(
        "/api/billing/portal",
        { returnUrl },
      );
      return res.data;
    },

    async getSubscription(): Promise<SubscriptionInfo | null> {
      const res = await apiClient.get<ApiEnvelope<SubscriptionInfo | null>>(
        "/api/billing/subscription",
      );
      return res.data;
    },

    async getPayments(): Promise<PaymentRecord[]> {
      const res = await apiClient.get<ApiEnvelope<PaymentRecord[]>>(
        "/api/billing/payments",
      );
      return res.data;
    },

    async cancelSubscription(): Promise<void> {
      await apiClient.post("/api/billing/cancel");
    },

    async upgrade(
      plan: string,
      successUrl: string,
      cancelUrl: string,
    ): Promise<{
      upgraded: boolean;
      targetPlan: string;
      method: string;
      sessionId?: string;
      url?: string;
    }> {
      const res = await apiClient.post<
        ApiEnvelope<{
          upgraded: boolean;
          targetPlan: string;
          method: string;
          sessionId?: string;
          url?: string;
        }>
      >("/api/billing/upgrade", { plan, successUrl, cancelUrl });
      return res.data;
    },

    async downgrade(plan: string): Promise<{ downgraded: boolean }> {
      const res = await apiClient.post<ApiEnvelope<{ downgraded: boolean }>>(
        "/api/billing/downgrade",
        { plan },
      );
      return res.data;
    },

    async validatePromo(code: string): Promise<PromoInfo> {
      const res = await apiClient.post<ApiEnvelope<PromoInfo>>(
        "/api/billing/validate-promo",
        { code },
      );
      return res.data;
    },
  },

  // ── Admin ───────────────────────────────────────────────────────
  admin: {
    async getStats(): Promise<AdminStats> {
      const res =
        await apiClient.get<ApiEnvelope<AdminStats>>("/api/admin/stats");
      return res.data;
    },

    async getMetrics(): Promise<{
      activeCrawls: number;
      errorsLast24h: number;
      systemTime: string;
    }> {
      const res = await apiClient.get<
        ApiEnvelope<{
          activeCrawls: number;
          errorsLast24h: number;
          systemTime: string;
        }>
      >("/api/admin/metrics");
      return res.data;
    },

    async getCustomers(params?: {
      page?: number;
      limit?: number;
      search?: string;
    }): Promise<PaginatedResponse<AdminCustomer>> {
      const qs = buildQueryString(params);
      return apiClient.get<PaginatedResponse<AdminCustomer>>(
        `/api/admin/customers${qs}`,
      );
    },

    async getCustomerDetail(userId: string): Promise<AdminCustomerDetail> {
      const res = await apiClient.get<ApiEnvelope<AdminCustomerDetail>>(
        `/api/admin/customers/${userId}`,
      );
      return res.data;
    },

    async getIngestDetails(): Promise<AdminIngestDetails> {
      const res =
        await apiClient.get<ApiEnvelope<AdminIngestDetails>>(
          "/api/admin/ingest",
        );
      return res.data;
    },

    async retryCrawlJob(jobId: string): Promise<void> {
      await apiClient.post(`/api/admin/ingest/jobs/${jobId}/retry`);
    },

    async replayOutboxEvent(eventId: string): Promise<void> {
      await apiClient.post(`/api/admin/ingest/outbox/${eventId}/replay`);
    },

    async cancelCrawlJob(jobId: string, reason?: string) {
      await apiClient.post(
        `/api/admin/ingest/jobs/${jobId}/cancel`,
        reason ? { reason } : undefined,
      );
    },

    async blockUser(id: string, reason?: string) {
      return apiClient.post(`/api/admin/customers/${id}/block`, { reason });
    },

    async suspendUser(id: string, reason?: string) {
      return apiClient.post(`/api/admin/customers/${id}/suspend`, { reason });
    },

    async unblockUser(id: string) {
      return apiClient.post(`/api/admin/customers/${id}/unblock`, {});
    },

    async changeUserPlan(id: string, plan: string) {
      return apiClient.post(`/api/admin/customers/${id}/change-plan`, {
        plan,
      });
    },

    async cancelUserSubscription(id: string) {
      return apiClient.post(
        `/api/admin/customers/${id}/cancel-subscription`,
        {},
      );
    },

    async listPromos(): Promise<Promo[]> {
      const res =
        await apiClient.get<ApiEnvelope<Promo[]>>("/api/admin/promos");
      return res.data;
    },

    async createPromo(data: {
      code: string;
      discountType: string;
      discountValue: number;
      duration: string;
      durationMonths?: number;
      maxRedemptions?: number;
      expiresAt?: string;
    }): Promise<Promo> {
      const res = await apiClient.post<ApiEnvelope<Promo>>(
        "/api/admin/promos",
        data,
      );
      return res.data;
    },

    async deactivatePromo(id: string) {
      return apiClient.delete(`/api/admin/promos/${id}`);
    },

    async applyPromo(userId: string, promoId: string) {
      return apiClient.post(`/api/admin/customers/${userId}/apply-promo`, {
        promoId,
      });
    },

    async getBlockedDomains(): Promise<BlockedDomain[]> {
      const res = await apiClient.get<ApiEnvelope<BlockedDomain[]>>(
        "/api/admin/blocked-domains",
      );
      return res.data;
    },

    async addBlockedDomain(
      domain: string,
      reason?: string,
    ): Promise<BlockedDomain> {
      const res = await apiClient.post<ApiEnvelope<BlockedDomain>>(
        "/api/admin/blocked-domains",
        { domain, reason },
      );
      return res.data;
    },

    async removeBlockedDomain(id: string): Promise<BlockedDomain> {
      const res = await apiClient.delete<ApiEnvelope<BlockedDomain>>(
        `/api/admin/blocked-domains/${id}`,
      );
      return res.data;
    },

    async getSettings(): Promise<{ http_fallback_enabled: boolean }> {
      const res = await apiClient.get<
        ApiEnvelope<{ http_fallback_enabled: boolean }>
      >("/api/admin/settings");
      return res.data;
    },

    async updateSetting(key: string, value: unknown) {
      const res = await apiClient.put<ApiEnvelope<unknown>>(
        `/api/admin/settings/${key}`,
        { value },
      );
      return res.data;
    },
  },

  // ── Scores ──────────────────────────────────────────────────────
  scores: {
    async listByJob(jobId: string): Promise<PageScoreEntry[]> {
      const res = await apiClient.get<ApiEnvelope<PageScoreEntry[]>>(
        `/api/scores/job/${jobId}/pages`,
      );
      return res.data;
    },

    async getPage(pageId: string): Promise<PageScoreDetail> {
      const res = await apiClient.get<ApiEnvelope<PageScoreDetail>>(
        `/api/scores/page/${pageId}`,
      );
      return res.data;
    },
  },

  // ── Visibility ─────────────────────────────────────────────────
  visibility: {
    async run(data: {
      projectId: string;
      keywordIds: string[];
      providers: string[];
      region?: string;
      language?: string;
    }): Promise<VisibilityCheck[]> {
      const res = await apiClient.post<ApiEnvelope<VisibilityCheck[]>>(
        "/api/visibility/check",
        data,
      );
      return res.data;
    },

    async suggestKeywords(projectId: string): Promise<string[]> {
      const res = await apiClient.post<ApiEnvelope<string[]>>(
        `/api/visibility/${projectId}/suggest-keywords`,
        {},
      );
      return res.data;
    },

    async list(
      projectId: string,
      filters?: { region?: string; language?: string },
    ): Promise<VisibilityCheck[]> {
      const params = new URLSearchParams();
      if (filters?.region) params.set("region", filters.region);
      if (filters?.language) params.set("language", filters.language);
      const qs = params.toString();
      const res = await apiClient.get<ApiEnvelope<VisibilityCheck[]>>(
        `/api/visibility/${projectId}${qs ? `?${qs}` : ""}`,
      );
      return res.data;
    },

    async getTrends(
      projectId: string,
      filters?: { region?: string; language?: string },
    ): Promise<VisibilityTrend[]> {
      const params = new URLSearchParams();
      if (filters?.region) params.set("region", filters.region);
      if (filters?.language) params.set("language", filters.language);
      const qs = params.toString();
      const res = await apiClient.get<ApiEnvelope<VisibilityTrend[]>>(
        `/api/visibility/${projectId}/trends${qs ? `?${qs}` : ""}`,
      );
      return res.data;
    },

    async getGaps(
      projectId: string,
      filters?: { region?: string; language?: string },
    ): Promise<VisibilityGap[]> {
      const params = new URLSearchParams();
      if (filters?.region) params.set("region", filters.region);
      if (filters?.language) params.set("language", filters.language);
      const qs = params.toString();
      const res = await apiClient.get<ApiEnvelope<VisibilityGap[]>>(
        `/api/visibility/${projectId}/gaps${qs ? `?${qs}` : ""}`,
      );
      return res.data;
    },

    async getCitedPages(
      projectId: string,
      filters?: { region?: string; language?: string },
    ): Promise<CitedPage[]> {
      const params = new URLSearchParams();
      if (filters?.region) params.set("region", filters.region);
      if (filters?.language) params.set("language", filters.language);
      const qs = params.toString();
      const res = await apiClient.get<ApiEnvelope<CitedPage[]>>(
        `/api/visibility/${projectId}/cited-pages${qs ? `?${qs}` : ""}`,
      );
      return res.data;
    },

    async getBrandPerformance(
      projectId: string,
      filters?: { region?: string; language?: string },
    ): Promise<BrandPerformance> {
      const params = new URLSearchParams();
      if (filters?.region) params.set("region", filters.region);
      if (filters?.language) params.set("language", filters.language);
      const qs = params.toString();
      const res = await apiClient.get<ApiEnvelope<BrandPerformance>>(
        `/api/visibility/${projectId}/brand-performance${qs ? `?${qs}` : ""}`,
      );
      return res.data;
    },

    async getSourceOpportunities(
      projectId: string,
      filters?: { region?: string; language?: string },
    ): Promise<SourceOpportunity[]> {
      const params = new URLSearchParams();
      if (filters?.region) params.set("region", filters.region);
      if (filters?.language) params.set("language", filters.language);
      const qs = params.toString();
      const res = await apiClient.get<ApiEnvelope<SourceOpportunity[]>>(
        `/api/visibility/${projectId}/source-opportunities${qs ? `?${qs}` : ""}`,
      );
      return res.data;
    },

    schedules: {
      async list(projectId: string): Promise<ScheduledQuery[]> {
        const res = await apiClient.get<ApiEnvelope<ScheduledQuery[]>>(
          `/api/visibility/schedules?projectId=${projectId}`,
        );
        return res.data;
      },

      async create(data: CreateScheduleInput): Promise<ScheduledQuery> {
        const res = await apiClient.post<ApiEnvelope<ScheduledQuery>>(
          "/api/visibility/schedules",
          data,
        );
        return res.data;
      },

      async update(
        id: string,
        data: Partial<ScheduleUpdate>,
      ): Promise<ScheduledQuery> {
        const res = await apiClient.patch<ApiEnvelope<ScheduledQuery>>(
          `/api/visibility/schedules/${id}`,
          data,
        );
        return res.data;
      },

      async delete(id: string): Promise<void> {
        await apiClient.delete(`/api/visibility/schedules/${id}`);
      },
    },

    async getAIScore(
      projectId: string,
      filters?: { region?: string; language?: string },
    ) {
      const params = new URLSearchParams();
      if (filters?.region) params.set("region", filters.region);
      if (filters?.language) params.set("language", filters.language);
      const qs = params.toString();
      const res = await apiClient.get<
        ApiEnvelope<{
          overall: number;
          grade: string;
          breakdown: {
            llmMentions: number;
            aiSearch: number;
            shareOfVoice: number;
            backlinkAuthority: number;
          };
          meta: {
            totalChecks: number;
            llmChecks: number;
            aiModeChecks: number;
            referringDomains: number;
          };
        }>
      >(`/api/visibility/${projectId}/ai-score${qs ? `?${qs}` : ""}`);
      return res.data;
    },

    async discoverKeywords(projectId: string) {
      const res = await apiClient.post<
        ApiEnvelope<{
          gscKeywords: {
            keyword: string;
            source: string;
            clicks?: number;
            impressions?: number;
          }[];
          llmKeywords: string[];
        }>
      >(`/api/visibility/${projectId}/discover-keywords`, {});
      return res.data;
    },

    async getScoreTrend(
      projectId: string,
      filters?: { region?: string; language?: string },
    ): Promise<AIScoreTrend> {
      const params = new URLSearchParams();
      if (filters?.region) params.set("region", filters.region);
      if (filters?.language) params.set("language", filters.language);
      const qs = params.toString();
      const res = await apiClient.get<ApiEnvelope<AIScoreTrend>>(
        `/api/visibility/${projectId}/ai-score/trend${qs ? `?${qs}` : ""}`,
      );
      return res.data;
    },

    async getRecommendations(
      projectId: string,
      filters?: { region?: string; language?: string },
    ): Promise<VisibilityRecommendation[]> {
      const params = new URLSearchParams();
      if (filters?.region) params.set("region", filters.region);
      if (filters?.language) params.set("language", filters.language);
      const qs = params.toString();
      const res = await apiClient.get<ApiEnvelope<VisibilityRecommendation[]>>(
        `/api/visibility/${projectId}/recommendations${qs ? `?${qs}` : ""}`,
      );
      return res.data;
    },
  },

  // ── Brand ────────────────────────────────────────────────────
  brand: {
    async getSentiment(
      projectId: string,
      filters?: { region?: string; language?: string },
    ): Promise<BrandSentiment> {
      const params = new URLSearchParams();
      if (filters?.region) params.set("region", filters.region);
      if (filters?.language) params.set("language", filters.language);
      const qs = params.toString();
      const res = await apiClient.get<ApiEnvelope<BrandSentiment>>(
        `/api/brand/${projectId}/sentiment${qs ? `?${qs}` : ""}`,
      );
      return res.data;
    },

    async getSentimentHistory(
      projectId: string,
    ): Promise<BrandSentimentSnapshot[]> {
      const res = await apiClient.get<ApiEnvelope<BrandSentimentSnapshot[]>>(
        `/api/brand/${projectId}/sentiment/history`,
      );
      return res.data;
    },

    async getPerception(
      projectId: string,
      filters?: { region?: string; language?: string },
    ): Promise<BrandPerceptionProvider[]> {
      const params = new URLSearchParams();
      if (filters?.region) params.set("region", filters.region);
      if (filters?.language) params.set("language", filters.language);
      const qs = params.toString();
      const res = await apiClient.get<ApiEnvelope<BrandPerceptionProvider[]>>(
        `/api/brand/${projectId}/perception${qs ? `?${qs}` : ""}`,
      );
      return res.data;
    },
  },

  // ── Prompt Research ─────────────────────────────────────────────
  promptResearch: {
    async discover(projectId: string): Promise<AIPrompt[]> {
      const res = await apiClient.post<ApiEnvelope<AIPrompt[]>>(
        `/api/prompt-research/${projectId}/discover`,
        {},
      );
      return res.data;
    },

    async list(
      projectId: string,
    ): Promise<{ data: AIPrompt[]; meta: { limit: number; plan: string } }> {
      const res = await apiClient.get<{
        data: AIPrompt[];
        meta: { limit: number; plan: string };
      }>(`/api/prompt-research/${projectId}`);
      return res;
    },

    async remove(projectId: string, promptId: string): Promise<void> {
      await apiClient.delete(`/api/prompt-research/${projectId}/${promptId}`);
    },

    async check(data: {
      projectId: string;
      promptId?: string;
      prompt?: string;
      providers?: string[];
      region?: string;
      language?: string;
    }): Promise<PromptCheckResult> {
      const res = await apiClient.post<ApiEnvelope<PromptCheckResult>>(
        `/api/prompt-research/${data.projectId}/check`,
        {
          promptId: data.promptId,
          prompt: data.prompt,
          providers: data.providers,
          region: data.region,
          language: data.language,
        },
      );
      return res.data;
    },
  },

  // ── Backlinks ─────────────────────────────────────────────────
  backlinks: {
    async getSummary(projectId: string) {
      const res = await apiClient.get<
        ApiEnvelope<{
          domain: string;
          totalBacklinks: number;
          referringDomains: number;
          dofollowRatio: number;
          topReferringDomains: {
            domain: string;
            linkCount: number;
            latestAnchor: string | null;
            firstSeen: string;
          }[];
        }>
      >(`/api/backlinks/project/${projectId}`);
      return res.data;
    },

    async getLinks(projectId: string, limit = 50, offset = 0) {
      const res = await apiClient.get<
        ApiEnvelope<{
          links: {
            sourceUrl: string;
            sourceDomain: string;
            targetUrl: string;
            anchorText: string | null;
            rel: string;
            lastSeenAt: string;
          }[];
          total: number;
          limit: number;
          offset: number;
        }>
      >(
        `/api/backlinks/project/${projectId}/links?limit=${limit}&offset=${offset}`,
      );
      return res.data;
    },

    async getReferringDomains(projectId: string) {
      const res = await apiClient.get<
        ApiEnvelope<
          {
            domain: string;
            linkCount: number;
            latestAnchor: string | null;
            firstSeen: string;
          }[]
        >
      >(`/api/backlinks/project/${projectId}/referring-domains`);
      return res.data;
    },
  },

  // ── Strategy ────────────────────────────────────────────────────
  strategy: {
    async generatePersonas(
      projectId: string,
      data: { description?: string; niche?: string },
    ): Promise<StrategyPersona[]> {
      const res = await apiClient.post<ApiEnvelope<StrategyPersona[]>>(
        `/api/strategy/${projectId}/personas`,
        data,
      );
      return res.data;
    },

    async getCompetitors(projectId: string): Promise<StrategyCompetitor[]> {
      const res = await apiClient.get<ApiEnvelope<StrategyCompetitor[]>>(
        `/api/strategy/${projectId}/competitors`,
      );
      return res.data;
    },

    async addCompetitor(
      projectId: string,
      domain: string,
    ): Promise<StrategyCompetitor> {
      const res = await apiClient.post<ApiEnvelope<StrategyCompetitor>>(
        `/api/strategy/${projectId}/competitors`,
        { domain },
      );
      return res.data;
    },

    async removeCompetitor(id: string): Promise<void> {
      await apiClient.delete(`/api/strategy/competitors/${id}`);
    },

    async gapAnalysis(data: {
      projectId: string;
      competitorDomain: string;
      query: string;
      pageId?: string;
    }): Promise<GapAnalysisResult> {
      const res = await apiClient.post<ApiEnvelope<GapAnalysisResult>>(
        "/api/strategy/gap-analysis",
        data,
      );
      return res.data;
    },

    async semanticGap(data: {
      projectId: string;
      pageId: string;
      competitorDomain: string;
    }): Promise<SemanticGapResponse> {
      const res = await apiClient.post<ApiEnvelope<SemanticGapResponse>>(
        "/api/strategy/semantic-gap",
        data,
      );
      return res.data;
    },

    async applyFix(data: {
      pageId: string;
      missingFact: string;
      factType: string;
    }): Promise<{
      suggestedSnippet: string;
      placementAdvice: string;
      citabilityBoost: number;
    }> {
      const res = await apiClient.post<
        ApiEnvelope<{
          suggestedSnippet: string;
          placementAdvice: string;
          citabilityBoost: number;
        }>
      >("/api/strategy/apply-fix", data);
      return res.data;
    },

    async getTopicMap(projectId: string): Promise<{
      nodes: {
        id: string;
        label: string;
        score: number;
        wordCount: number;
        cluster: string;
        val: number;
      }[];
      edges: { source: string; target: string }[];
      clusters: { id: string; label: string }[];
    }> {
      const res = await apiClient.get<
        ApiEnvelope<{
          nodes: {
            id: string;
            label: string;
            score: number;
            wordCount: number;
            cluster: string;
            val: number;
          }[];
          edges: { source: string; target: string }[];
          clusters: { id: string; label: string }[];
        }>
      >(`/api/strategy/${projectId}/topic-map`);
      return res.data;
    },

    async optimizeDimension(data: {
      pageId: string;
      content: string;
      dimension: string;
      tone?: string;
    }): Promise<{ optimized: string; explanation: string }> {
      const res = await apiClient.post<
        ApiEnvelope<{ optimized: string; explanation: string }>
      >("/api/strategy/optimize-dimension", data);
      return res.data;
    },
  },

  // ── Personas ─────────────────────────────────────────────────────
  personas: {
    async list(projectId: string): Promise<Persona[]> {
      const res = await apiClient.get<ApiEnvelope<Persona[]>>(
        `/api/personas/${projectId}`,
      );
      return res.data;
    },
    async create(projectId: string, data: Partial<Persona>): Promise<Persona> {
      const res = await apiClient.post<ApiEnvelope<Persona>>(
        `/api/personas/${projectId}`,
        data,
      );
      return res.data;
    },
    async update(id: string, data: Partial<Persona>): Promise<Persona> {
      const res = await apiClient.patch<ApiEnvelope<Persona>>(
        `/api/personas/${id}`,
        data,
      );
      return res.data;
    },
    async remove(id: string): Promise<void> {
      await apiClient.delete(`/api/personas/${id}`);
    },
    async generate(projectId: string, role: string): Promise<Partial<Persona>> {
      const res = await apiClient.post<ApiEnvelope<Partial<Persona>>>(
        `/api/personas/${projectId}/generate`,
        { role },
      );
      return res.data;
    },
    async refine(id: string): Promise<Partial<Persona>> {
      const res = await apiClient.post<ApiEnvelope<Partial<Persona>>>(
        `/api/personas/${id}/refine`,
        {},
      );
      return res.data;
    },
  },

  // ── Keywords ─────────────────────────────────────────────────────
  keywords: {
    async list(projectId: string): Promise<SavedKeyword[]> {
      const res = await apiClient.get<ApiEnvelope<SavedKeyword[]>>(
        `/api/keywords/${projectId}`,
      );
      return res.data;
    },
    async create(
      projectId: string,
      data: { keyword: string; funnelStage?: string; personaId?: string },
    ): Promise<SavedKeyword> {
      const res = await apiClient.post<ApiEnvelope<SavedKeyword>>(
        `/api/keywords/${projectId}`,
        data,
      );
      return res.data;
    },
    async remove(id: string): Promise<void> {
      await apiClient.delete(`/api/keywords/${id}`);
    },
    async createBatch(
      projectId: string,
      keywords: string[],
    ): Promise<SavedKeyword[]> {
      const res = await apiClient.post<ApiEnvelope<SavedKeyword[]>>(
        `/api/keywords/${projectId}/batch`,
        { keywords },
      );
      return res.data;
    },
  },

  // ── Discovery ────────────────────────────────────────────────────
  discovery: {
    async run(projectId: string): Promise<DiscoveryResult> {
      const res = await apiClient.post<ApiEnvelope<DiscoveryResult>>(
        `/api/discovery/${projectId}/run`,
        {},
      );
      return res.data;
    },
  },

  // ── Account ─────────────────────────────────────────────────────
  account: {
    async getMe(): Promise<{
      isAdmin: boolean;
      plan: string;
      email: string;
      onboardingComplete: boolean;
      persona: string | null;
      digestFrequency: string | null;
    }> {
      const res = await apiClient.get<
        ApiEnvelope<{
          isAdmin: boolean;
          plan: string;
          email: string;
          onboardingComplete: boolean;
          persona: string | null;
          digestFrequency: string | null;
        }>
      >("/api/account");
      return res.data;
    },

    async getPreferences(): Promise<AccountPreferences> {
      const res = await apiClient.get<ApiEnvelope<AccountPreferences>>(
        "/api/account/preferences",
      );
      return res.data;
    },

    async updatePreferences(
      data: Partial<AccountPreferences>,
    ): Promise<AccountPreferences> {
      const res = await apiClient.put<ApiEnvelope<AccountPreferences>>(
        "/api/account/preferences",
        data,
      );
      return res.data;
    },

    async updateProfile(data: {
      name?: string;
      phone?: string;
      onboardingComplete?: boolean;
      persona?: string;
      digestFrequency?: string;
    }): Promise<void> {
      await apiClient.put("/api/account", data);
    },

    async classifyPersona(data: {
      teamSize: string;
      primaryGoal: string;
      domain?: string;
    }): Promise<{
      persona: string;
      confidence: "high" | "medium";
      reasoning: string;
    }> {
      const res = await apiClient.post<
        ApiEnvelope<{
          persona: string;
          confidence: "high" | "medium";
          reasoning: string;
        }>
      >("/api/account/classify-persona", data);
      return res.data;
    },

    async deleteAccount(): Promise<void> {
      await apiClient.delete<void>("/api/account");
    },

    async getNotifications(): Promise<NotificationPreferences> {
      const res = await apiClient.get<ApiEnvelope<NotificationPreferences>>(
        "/api/account/notifications",
      );
      return res.data;
    },

    async updateNotifications(
      data: Partial<NotificationPreferences>,
    ): Promise<NotificationPreferences> {
      const res = await apiClient.put<ApiEnvelope<NotificationPreferences>>(
        "/api/account/notifications",
        data,
      );
      return res.data;
    },

    async getDigestPreferences(): Promise<DigestPreferences> {
      const res = await apiClient.get<ApiEnvelope<DigestPreferences>>(
        "/api/account/digest",
      );
      return res.data;
    },

    async updateDigestPreferences(
      data: Partial<DigestPreferences>,
    ): Promise<DigestPreferences> {
      const res = await apiClient.put<ApiEnvelope<DigestPreferences>>(
        "/api/account/digest",
        data,
      );
      return res.data;
    },
  },

  // ── Public (no auth) ──────────────────────────────────────────
  public: {
    async scan(
      url: string,
    ): Promise<PublicScanResult & { scanResultId?: string }> {
      const domain = normalizeDomain(url);
      const res = await apiClient.post<
        ApiEnvelope<PublicScanResult & { scanResultId?: string }>
      >("/api/public/scan", { url: domain });
      return res.data;
    },

    async getReport(token: string): Promise<SharedReport> {
      const res = await apiClient.get<ApiEnvelope<SharedReport>>(
        `/api/public/reports/${token}`,
      );
      return res.data;
    },

    async getScanResult(id: string, token?: string): Promise<PublicScanResult> {
      const params = token ? `?token=${token}` : "";
      const res = await apiClient.get<ApiEnvelope<PublicScanResult>>(
        `/api/public/scan-results/${id}${params}`,
      );
      return res.data;
    },

    async captureLead(data: {
      email: string;
      reportToken?: string;
      scanResultId?: string;
    }): Promise<{ id: string }> {
      const res = await apiClient.post<ApiEnvelope<{ id: string }>>(
        "/api/public/leads",
        data,
      );
      return res.data;
    },

    async leaderboard(): Promise<
      {
        projectId: string;
        domain: string;
        overallScore: number;
        grade: string;
        aiReadinessScore: number;
      }[]
    > {
      const res = await apiClient.get<
        ApiEnvelope<
          {
            projectId: string;
            domain: string;
            overallScore: number;
            grade: string;
            aiReadinessScore: number;
          }[]
        >
      >("/api/public/leaderboard");
      return res.data;
    },

    async integrationCatalog(): Promise<IntegrationCatalogItem[]> {
      const res = await apiClient.get<ApiEnvelope<IntegrationCatalogItem[]>>(
        "/api/integrations/catalog",
      );
      return res.data;
    },

    async isHttpFallbackEnabled(): Promise<boolean> {
      const res = await apiClient.get<{ enabled: boolean }>(
        "/api/public/settings/http-fallback",
      );
      return res.enabled;
    },
  },

  // ── Reports ─────────────────────────────────────────────────────
  reports: {
    async generate(input: {
      projectId: string;
      crawlJobId: string;
      type: "summary" | "detailed";
      format: "pdf" | "docx";
      config?: {
        compareCrawlIds?: string[];
        brandingColor?: string;
        preparedFor?: string;
      };
    }): Promise<Report> {
      const res = await apiClient.post<ApiEnvelope<Report>>(
        "/api/reports/generate",
        input,
      );
      return res.data;
    },

    async list(projectId: string): Promise<Report[]> {
      const res = await apiClient.get<ApiEnvelope<Report[]>>(
        `/api/reports?projectId=${projectId}`,
      );
      return res.data;
    },

    async getStatus(reportId: string): Promise<Report> {
      const res = await apiClient.get<ApiEnvelope<Report>>(
        `/api/reports/${reportId}`,
      );
      return res.data;
    },

    async download(reportId: string): Promise<Blob> {
      const res = await fetch(apiUrl(`/api/reports/${reportId}/download`), {
        credentials: "include",
      });
      if (!res.ok) {
        const text = await res.text();
        console.error("Report download failed:", res.status, text);
        let err;
        try {
          err = JSON.parse(text);
        } catch {
          err = {
            error: { code: "DOWNLOAD_ERROR", message: "Download failed" },
          };
        }
        throw new ApiError(
          res.status,
          err.error?.code ?? "DOWNLOAD_ERROR",
          err.error?.message ?? "Download failed",
        );
      }
      return res.blob();
    },

    async delete(reportId: string): Promise<void> {
      await apiClient.delete(`/api/reports/${reportId}`);
    },

    schedules: {
      async list(projectId: string): Promise<ReportSchedule[]> {
        const res = await apiClient.get<ApiEnvelope<ReportSchedule[]>>(
          `/api/reports/schedules?projectId=${projectId}`,
        );
        return res.data;
      },

      async create(data: {
        projectId: string;
        format: "pdf" | "docx";
        type: "summary" | "detailed";
        recipientEmail: string;
      }): Promise<ReportSchedule> {
        const res = await apiClient.post<ApiEnvelope<ReportSchedule>>(
          "/api/reports/schedules",
          data,
        );
        return res.data;
      },

      async update(
        id: string,
        data: Partial<{
          format: "pdf" | "docx";
          type: "summary" | "detailed";
          recipientEmail: string;
          enabled: boolean;
        }>,
      ): Promise<ReportSchedule> {
        const res = await apiClient.patch<ApiEnvelope<ReportSchedule>>(
          `/api/reports/schedules/${id}`,
          data,
        );
        return res.data;
      },

      async delete(id: string): Promise<void> {
        await apiClient.delete(`/api/reports/schedules/${id}`);
      },
    },
  },

  // ── Pipeline Recommendations ──────────────────────────────────
  pipeline: {
    async recommendations(
      projectId: string,
    ): Promise<PipelineRecommendation[]> {
      const res = await apiClient.get<ApiEnvelope<PipelineRecommendation[]>>(
        `/api/pipeline/${projectId}/recommendations`,
      );
      return res.data;
    },

    async list(projectId: string): Promise<PipelineRun[]> {
      const res = await apiClient.get<ApiEnvelope<PipelineRun[]>>(
        `/api/pipeline/${projectId}`,
      );
      return res.data;
    },

    async latest(projectId: string): Promise<PipelineRun | null> {
      const res = await apiClient.get<ApiEnvelope<PipelineRun | null>>(
        `/api/pipeline/${projectId}/latest`,
      );
      return res.data;
    },

    async updateSettings(
      projectId: string,
      data: Record<string, unknown>,
    ): Promise<Record<string, unknown>> {
      const res = await apiClient.patch<ApiEnvelope<Record<string, unknown>>>(
        `/api/pipeline/${projectId}/settings`,
        data,
      );
      return res.data;
    },

    async healthCheck(projectId: string): Promise<PipelineHealthCheckResult> {
      const res = await apiClient.get<ApiEnvelope<PipelineHealthCheckResult>>(
        `/api/pipeline/${projectId}/health-check`,
      );
      return res.data;
    },
  },

  // ── Quick Wins ─────────────────────────────────────────────────
  quickWins: {
    async get(crawlId: string): Promise<QuickWin[]> {
      const res = await apiClient.get<ApiEnvelope<QuickWin[]>>(
        `/api/crawls/${crawlId}/quick-wins`,
      );
      return res.data;
    },
  },

  // ── Platform Readiness ─────────────────────────────────────────
  platformReadiness: {
    async get(crawlId: string): Promise<PlatformReadinessResult[]> {
      const res = await apiClient.get<ApiEnvelope<PlatformReadinessResult[]>>(
        `/api/crawls/${crawlId}/platform-readiness`,
      );
      return res.data;
    },
  },

  // ── Logs ───────────────────────────────────────────────────────
  logs: {
    async upload(
      projectId: string,
      data: { filename: string; content: string },
    ): Promise<{ id: string; summary: LogAnalysisSummary }> {
      const res = await apiClient.post<
        ApiEnvelope<{ id: string; summary: LogAnalysisSummary }>
      >(`/api/logs/${projectId}/upload`, data);
      return res.data;
    },

    async list(projectId: string): Promise<LogUpload[]> {
      const res = await apiClient.get<ApiEnvelope<LogUpload[]>>(
        `/api/logs/${projectId}`,
      );
      return res.data;
    },

    async getCrawlerTimeline(
      projectId: string,
    ): Promise<CrawlerTimelinePoint[]> {
      const res = await apiClient.get<ApiEnvelope<CrawlerTimelinePoint[]>>(
        `/api/logs/${projectId}/crawler-timeline`,
      );
      return res.data;
    },
  },

  // ── Integrations ────────────────────────────────────────────────
  integrations: {
    async list(projectId: string): Promise<ProjectIntegration[]> {
      const res = await apiClient.get<ApiEnvelope<ProjectIntegration[]>>(
        `/api/integrations/${projectId}`,
      );
      return res.data;
    },

    async connect(
      projectId: string,
      data: {
        provider: string;
        apiKey?: string;
        clarityProjectId?: string;
      },
    ): Promise<ProjectIntegration> {
      const res = await apiClient.post<ApiEnvelope<ProjectIntegration>>(
        `/api/integrations/${projectId}/connect`,
        data,
      );
      return res.data;
    },

    async update(
      projectId: string,
      integrationId: string,
      data: { enabled?: boolean; config?: Record<string, unknown> },
    ): Promise<ProjectIntegration> {
      const res = await apiClient.put<ApiEnvelope<ProjectIntegration>>(
        `/api/integrations/${projectId}/${integrationId}`,
        data,
      );
      return res.data;
    },

    async disconnect(projectId: string, integrationId: string): Promise<void> {
      await apiClient.delete(`/api/integrations/${projectId}/${integrationId}`);
    },

    async insights(
      projectId: string,
      crawlId?: string,
    ): Promise<IntegrationInsights> {
      const query = crawlId ? `?crawlId=${encodeURIComponent(crawlId)}` : "";
      const res = await apiClient.get<ApiEnvelope<IntegrationInsights>>(
        `/api/integrations/${projectId}/insights${query}`,
      );
      return res.data;
    },

    async startGoogleOAuth(
      projectId: string,
      provider: "gsc" | "ga4",
    ): Promise<{ url: string }> {
      const res = await apiClient.post<ApiEnvelope<{ url: string }>>(
        `/api/integrations/${projectId}/oauth/google/start`,
        { provider },
      );
      return res.data;
    },

    async oauthCallback(data: {
      code: string;
      state: string;
      redirectUri: string;
    }): Promise<ProjectIntegration> {
      const res = await apiClient.post<ApiEnvelope<ProjectIntegration>>(
        `/api/integrations/oauth/google/callback`,
        data,
      );
      return res.data;
    },

    async sync(projectId: string): Promise<{
      synced: boolean;
      enrichmentCount: number;
      crawlId: string;
      providers?: {
        provider: string;
        ok: boolean;
        count: number;
        error?: string;
      }[];
    }> {
      const res = await apiClient.post<
        ApiEnvelope<{
          synced: boolean;
          enrichmentCount: number;
          crawlId: string;
          providers?: {
            provider: string;
            ok: boolean;
            count: number;
            error?: string;
          }[];
        }>
      >(`/api/integrations/${projectId}/sync`);
      return res.data;
    },

    async test(
      projectId: string,
      integrationId: string,
    ): Promise<{ ok: boolean; message: string }> {
      const res = await apiClient.post<
        ApiEnvelope<{ ok: boolean; message: string }>
      >(`/api/integrations/${projectId}/${integrationId}/test`);
      return res.data;
    },
  },

  // ── Share ──────────────────────────────────────────────────────
  share: {
    async enable(
      crawlId: string,
      options?: {
        level?: "summary" | "issues" | "full";
        expiresAt?: string | null;
      },
    ): Promise<ShareInfo> {
      const res = await apiClient.post<ApiEnvelope<ShareInfo>>(
        `/api/crawls/${crawlId}/share`,
        options,
      );
      return res.data;
    },

    async update(
      crawlId: string,
      settings: {
        level?: "summary" | "issues" | "full";
        expiresAt?: string | null;
      },
    ): Promise<ShareInfo> {
      const res = await apiClient.patch<ApiEnvelope<ShareInfo>>(
        `/api/crawls/${crawlId}/share`,
        settings,
      );
      return res.data;
    },

    async disable(crawlId: string): Promise<void> {
      await apiClient.delete(`/api/crawls/${crawlId}/share`);
    },

    async getPublicReport(token: string): Promise<PublicReport> {
      const res = await fetch(apiUrl(`/api/public/reports/${token}`));
      if (!res.ok) throw new Error("Report not found");
      const json = await res.json();
      return json.data;
    },
  },

  // ── Notification Channels ────────────────────────────────────
  channels: {
    async list(): Promise<NotificationChannel[]> {
      const res = await apiClient.get<ApiEnvelope<NotificationChannel[]>>(
        "/api/notification-channels",
      );
      return res.data;
    },

    async create(data: CreateChannelInput): Promise<NotificationChannel> {
      const res = await apiClient.post<ApiEnvelope<NotificationChannel>>(
        "/api/notification-channels",
        data,
      );
      return res.data;
    },

    async update(
      id: string,
      data: Partial<ChannelUpdate>,
    ): Promise<NotificationChannel> {
      const res = await apiClient.patch<ApiEnvelope<NotificationChannel>>(
        `/api/notification-channels/${id}`,
        data,
      );
      return res.data;
    },

    async delete(id: string): Promise<void> {
      await apiClient.delete(`/api/notification-channels/${id}`);
    },
  },

  // ── AI Fixes ───────────────────────────────────────────────
  fixes: {
    async generate(data: {
      projectId: string;
      pageId?: string;
      issueCode: string;
    }): Promise<{ generatedFix: string; fixType: string }> {
      const res = await apiClient.post<
        ApiEnvelope<{ generatedFix: string; fixType: string }>
      >("/api/fixes/generate", data);
      return res.data;
    },

    async getHistory(page = 1, limit = 50) {
      return apiClient.get<PaginatedResponse<CrawlJobSummary>>(
        `/crawls/history?page=${page}&limit=${limit}`,
      );
    },
    async list(projectId: string) {
      const res = await apiClient.get<ApiEnvelope<unknown[]>>(
        `/api/fixes?projectId=${projectId}`,
      );
      return res.data;
    },

    async supported() {
      const res = await apiClient.get<ApiEnvelope<string[]>>(
        "/api/fixes/supported",
      );
      return res.data;
    },

    async generateBatch(data: { projectId: string; crawlId: string }) {
      const res = await apiClient.post<
        ApiEnvelope<
          Array<{
            code: string;
            fix: { generatedFix: string; fixType: string } | null;
            error: string | null;
          }>
        >
      >("/api/fixes/generate-batch", data);
      return res.data;
    },
  },

  // ── Trends ─────────────────────────────────────────────────────
  trends: {
    async get(projectId: string, period = "90d") {
      const res = await apiClient.get<
        ApiEnvelope<{ points: unknown[]; deltas: unknown }>
      >(`/api/trends/${projectId}?period=${period}`);
      const points = res.data?.points ?? [];
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return points.map((p: any) => ({
        date: p.date,
        overall: p.overall ?? 0,
        technical: p.technical ?? 0,
        content: p.content ?? 0,
        aiReadiness: p.aiReadiness ?? 0,
        performance: p.performance ?? 0,
        delta: p.deltas?.overall ?? undefined,
      }));
    },

    async getRegressions(projectId: string): Promise<Regression[]> {
      const res = await apiClient.get<ApiEnvelope<Regression[]>>(
        `/api/trends/${projectId}/regressions`,
      );
      return res.data;
    },
  },

  // ── API Tokens ───────────────────────────────────────────────
  tokens: {
    async list(): Promise<ApiTokenInfo[]> {
      const res =
        await apiClient.get<ApiEnvelope<ApiTokenInfo[]>>("/api/tokens");
      return res.data;
    },

    async create(data: CreateTokenInput): Promise<ApiTokenWithPlaintext> {
      const res = await apiClient.post<ApiEnvelope<ApiTokenWithPlaintext>>(
        "/api/tokens",
        data,
      );
      return res.data;
    },

    async revoke(id: string): Promise<void> {
      await apiClient.delete(`/api/tokens/${id}`);
    },
  },

  // ── Scoring Profiles ────────────────────────────────────────
  scoringProfiles: {
    async list(): Promise<ScoringProfile[]> {
      const res = await apiClient.get<ApiEnvelope<ScoringProfile[]>>(
        "/api/scoring-profiles",
      );
      return res.data;
    },
    async create(data: {
      name: string;
      weights: ScoringProfile["weights"];
    }): Promise<ScoringProfile> {
      const res = await apiClient.post<ApiEnvelope<ScoringProfile>>(
        "/api/scoring-profiles",
        data,
      );
      return res.data;
    },
    async update(
      id: string,
      data: Partial<{ name: string; weights: ScoringProfile["weights"] }>,
    ): Promise<ScoringProfile> {
      const res = await apiClient.put<ApiEnvelope<ScoringProfile>>(
        `/api/scoring-profiles/${id}`,
        data,
      );
      return res.data;
    },
    async delete(id: string): Promise<void> {
      await apiClient.delete(`/api/scoring-profiles/${id}`);
    },
  },

  // ── Teams ───────────────────────────────────────────────────
  organizations: {
    async getCurrent(): Promise<Organization | null> {
      const res =
        await apiClient.get<ApiEnvelope<Organization | null>>("/api/orgs");
      return res.data;
    },
    async create(data: { name: string; slug: string }): Promise<Organization> {
      const res = await apiClient.post<ApiEnvelope<Organization>>(
        "/api/orgs",
        data,
      );
      return res.data;
    },
    async getById(id: string): Promise<Organization> {
      const res = await apiClient.get<ApiEnvelope<Organization>>(
        `/api/orgs/${id}`,
      );
      return res.data;
    },
    async listMembers(orgId: string): Promise<OrganizationMember[]> {
      const res = await apiClient.get<ApiEnvelope<OrganizationMember[]>>(
        `/api/orgs/${orgId}/members`,
      );
      return res.data;
    },
    async invite(
      orgId: string,
      data: { email: string; role?: "admin" | "member" | "viewer" },
    ): Promise<OrganizationInvite> {
      const res = await apiClient.post<ApiEnvelope<OrganizationInvite>>(
        `/api/orgs/${orgId}/invites`,
        {
          email: data.email,
          role: data.role ?? "member",
        },
      );
      return res.data;
    },
    async listInvites(orgId: string): Promise<OrganizationInvite[]> {
      const res = await apiClient.get<ApiEnvelope<OrganizationInvite[]>>(
        `/api/orgs/${orgId}/invites`,
      );
      return res.data;
    },
    async acceptInvite(token: string): Promise<unknown> {
      const res = await apiClient.post<ApiEnvelope<unknown>>(
        "/api/orgs/accept-invite",
        { token },
      );
      return res.data;
    },
    async updateMemberRole(
      orgId: string,
      memberId: string,
      role: "admin" | "member" | "viewer",
    ): Promise<OrganizationMember> {
      const res = await apiClient.patch<ApiEnvelope<OrganizationMember>>(
        `/api/orgs/${orgId}/members/${memberId}`,
        { role },
      );
      return res.data;
    },
    async removeMember(orgId: string, memberId: string): Promise<void> {
      await apiClient.delete(`/api/orgs/${orgId}/members/${memberId}`);
    },
  },

  // ── Teams (Legacy compatibility adapter) ─────────────────────
  teams: {
    async list(): Promise<Team[]> {
      const org = await api.organizations.getCurrent();
      if (!org) return [];
      return [
        {
          id: org.id,
          name: org.name,
          ownerId: "",
          plan: "",
          role: "owner",
          createdAt: org.createdAt,
        },
      ];
    },
    async create(name: string): Promise<Team> {
      const slug = name
        .toLowerCase()
        .trim()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-|-$/g, "")
        .slice(0, 64);
      const org = await api.organizations.create({
        name,
        slug,
      });
      return {
        id: org.id,
        name: org.name,
        ownerId: "",
        plan: "",
        role: "owner",
        createdAt: org.createdAt,
      };
    },
    async getById(id: string): Promise<TeamDetail> {
      const [org, members] = await Promise.all([
        api.organizations.getById(id),
        api.organizations.listMembers(id),
      ]);
      return {
        id: org.id,
        name: org.name,
        ownerId: "",
        plan: "",
        createdAt: org.createdAt,
        role: "owner",
        members: members.map((m) => ({
          id: m.id,
          teamId: org.id,
          userId: m.userId,
          name: m.name,
          email: m.email,
          role: m.role === "member" ? "editor" : m.role,
          joinedAt: m.joinedAt,
        })),
      };
    },
    async invite(
      teamId: string,
      data: { email: string; role?: string },
    ): Promise<unknown> {
      return api.organizations.invite(teamId, {
        email: data.email,
        role:
          data.role === "admin" || data.role === "viewer"
            ? data.role
            : "member",
      });
    },
    async acceptInvite(token: string): Promise<unknown> {
      return api.organizations.acceptInvite(token);
    },
    async updateRole(
      teamId: string,
      memberId: string,
      role: string,
    ): Promise<unknown> {
      return api.organizations.updateMemberRole(
        teamId,
        memberId,
        role === "admin" || role === "viewer" ? role : "member",
      );
    },
    async removeMember(teamId: string, memberId: string): Promise<void> {
      await api.organizations.removeMember(teamId, memberId);
    },
  },

  // ── Generators ──────────────────────────────────────────────
  generators: {
    async sitemap(projectId: string): Promise<{
      filename: string | null;
      contentType: string | null;
      content: string;
    }> {
      return postDownload(`/api/projects/${projectId}/generate/sitemap`);
    },
    async llmsTxt(projectId: string): Promise<{
      filename: string | null;
      contentType: string | null;
      content: string;
    }> {
      return postDownload(`/api/projects/${projectId}/generate/llms-txt`);
    },
  },

  // ── Exports ───────────────────────────────────────────────
  exports: {
    download(projectId: string, format: "csv" | "json") {
      window.open(
        apiUrl(`/api/projects/${projectId}/export?format=${format}`),
        "_blank",
      );
    },
  },

  // ── Benchmarks ──────────────────────────────────────────────
  benchmarks: {
    async get(): Promise<Benchmarks | null> {
      const res = await apiClient.get<ApiEnvelope<Benchmarks | null>>(
        "/api/public/benchmarks",
      );
      return res.data;
    },
    async list(projectId: string): Promise<{
      projectScores: Record<string, number>;
      competitors: Array<{
        competitorDomain: string;
        scores: Record<string, number>;
        comparison: Record<string, number>;
        crawledAt: string;
      }>;
    }> {
      const res = await apiClient.get<
        ApiEnvelope<{
          projectScores: Record<string, number>;
          competitors: Array<{
            competitorDomain: string;
            scores: Record<string, number>;
            comparison: Record<string, number>;
            crawledAt: string;
          }>;
        }>
      >(`/api/competitors?projectId=${projectId}`);
      return res.data;
    },
    async trigger(data: {
      projectId: string;
      competitorDomain: string;
    }): Promise<void> {
      await apiClient.post(`/api/competitors/benchmark`, {
        projectId: data.projectId,
        competitorDomain: data.competitorDomain,
      });
    },
  },

  // ── Competitor Monitoring ────────────────────────────────────
  competitorMonitoring: {
    async getFeed(
      projectId: string,
      opts?: {
        limit?: number;
        offset?: number;
        type?: string;
        severity?: string;
        domain?: string;
      },
    ) {
      const params = new URLSearchParams({ projectId });
      if (opts?.limit) params.set("limit", String(opts.limit));
      if (opts?.offset) params.set("offset", String(opts.offset));
      if (opts?.type) params.set("type", opts.type);
      if (opts?.severity) params.set("severity", opts.severity);
      if (opts?.domain) params.set("domain", opts.domain);
      return apiClient.get<any>(`/api/competitors/feed?${params}`);
    },
    async getTrends(projectId: string, domain: string, period = 90) {
      const params = new URLSearchParams({
        projectId,
        domain,
        period: String(period),
      });
      return apiClient.get<any>(`/api/competitors/trends?${params}`);
    },
    async getCadence(projectId: string) {
      return apiClient.get<any>(
        `/api/competitors/cadence?projectId=${projectId}`,
      );
    },
    async updateMonitoring(
      competitorId: string,
      data: { enabled?: boolean; frequency?: string },
    ) {
      return apiClient.patch<any>(
        `/api/competitors/${competitorId}/monitoring`,
        data,
      );
    },
    async rebenchmark(competitorId: string) {
      return apiClient.post<any>(
        `/api/competitors/${competitorId}/rebenchmark`,
        {},
      );
    },
    async createWatchlistQuery(data: {
      projectId: string;
      query: string;
      providers: string[];
      frequency?: string;
    }) {
      return apiClient.post<any>("/api/competitors/watchlist", data);
    },
    async getWatchlist(projectId: string) {
      return apiClient.get<any>(
        `/api/competitors/watchlist?projectId=${projectId}`,
      );
    },
    async updateWatchlistQuery(
      id: string,
      data: {
        query?: string;
        providers?: string[];
        frequency?: string;
        enabled?: boolean;
      },
    ) {
      return apiClient.patch<any>(`/api/competitors/watchlist/${id}`, data);
    },
    async deleteWatchlistQuery(id: string) {
      return apiClient.delete<any>(`/api/competitors/watchlist/${id}`);
    },
  },

  queue: {
    async list(params?: {
      page?: number;
      limit?: number;
    }): Promise<PaginatedResponse<CrawlJobSummary>> {
      const searchParams = new URLSearchParams();
      if (params?.page) searchParams.set("page", params.page.toString());
      if (params?.limit) searchParams.set("limit", params.limit.toString());
      const qs = searchParams.toString() ? `?${searchParams.toString()}` : "";
      return apiClient.get<PaginatedResponse<CrawlJobSummary>>(
        `/api/queue${qs}`,
      );
    },
  },

  // ── Action Items ───────────────────────────────────────────────
  actionItems: {
    async create(data: {
      projectId: string;
      issueCode: string;
      status?: ActionItemStatus;
      severity?: "critical" | "warning" | "info";
      category?:
        | "technical"
        | "content"
        | "ai_readiness"
        | "performance"
        | "schema"
        | "llm_visibility";
      scoreImpact?: number;
      title: string;
      description?: string | null;
      assigneeId?: string | null;
      dueAt?: string | null;
    }): Promise<ActionItem> {
      const res = await apiClient.post<ApiEnvelope<ActionItem>>(
        "/api/action-items",
        data,
      );
      return res.data;
    },

    async update(
      id: string,
      data: Partial<{
        status: ActionItemStatus;
        assigneeId: string | null;
        dueAt: string | null;
        title: string;
        description: string | null;
      }>,
    ): Promise<ActionItem> {
      const res = await apiClient.patch<ApiEnvelope<ActionItem>>(
        `/api/action-items/${id}`,
        data,
      );
      return res.data;
    },

    async list(projectId: string): Promise<ActionItem[]> {
      const res = await apiClient.get<ApiEnvelope<ActionItem[]>>(
        `/api/action-items?projectId=${projectId}`,
      );
      return res.data;
    },

    async updateStatus(
      id: string,
      status: ActionItemStatus,
    ): Promise<ActionItem> {
      const res = await apiClient.patch<ApiEnvelope<ActionItem>>(
        `/api/action-items/${id}/status`,
        { status },
      );
      return res.data;
    },

    async stats(projectId: string): Promise<ActionItemStats> {
      const res = await apiClient.get<ApiEnvelope<ActionItemStats>>(
        `/api/action-items/stats?projectId=${projectId}`,
      );
      return res.data;
    },
  },

  // ── Alerts ─────────────────────────────────────────────────────
  alerts: {
    async list(projectId: string) {
      const res = await apiClient.get<
        ApiEnvelope<
          {
            id: string;
            projectId: string;
            type: string;
            severity: "critical" | "warning" | "info";
            message: string;
            data: unknown;
            acknowledgedAt: string | null;
            createdAt: string;
          }[]
        >
      >(`/api/alerts?projectId=${projectId}`);
      return res.data;
    },

    async acknowledge(id: string) {
      const res = await apiClient.post<ApiEnvelope<unknown>>(
        `/api/alerts/${id}/acknowledge`,
        {},
      );
      return res.data;
    },

    async acknowledgeAll(projectId: string) {
      const res = await apiClient.post<ApiEnvelope<{ success: boolean }>>(
        `/api/alerts/acknowledge-all?projectId=${projectId}`,
        {},
      );
      return res.data;
    },
  },

  // ── Trial ──────────────────────────────────────────────────────
  trial: {
    async status(): Promise<{
      eligible: boolean;
      active: boolean;
      daysRemaining?: number;
    }> {
      const res = await apiClient.get<
        ApiEnvelope<{
          eligible: boolean;
          active: boolean;
          daysRemaining?: number;
        }>
      >("/api/trial/status");
      return res.data;
    },

    async start(): Promise<{
      trialStartedAt: string;
      trialEndsAt: string;
      daysRemaining: number;
    }> {
      const res = await apiClient.post<
        ApiEnvelope<{
          trialStartedAt: string;
          trialEndsAt: string;
          daysRemaining: number;
        }>
      >("/api/trial/start", {});
      return res.data;
    },
  },

  // ── Narratives ─────────────────────────────────────────────────
  narratives: {
    async generate(
      crawlJobId: string,
      tone: "technical" | "business" = "technical",
    ) {
      const res = await apiClient.post<ApiEnvelope<any>>(
        "/api/narratives/generate",
        { crawlJobId, tone },
      );
      return res.data;
    },
    async get(
      crawlJobId: string,
      tone: "technical" | "business" = "technical",
    ) {
      const res = await apiClient.get<ApiEnvelope<any>>(
        `/api/narratives/${crawlJobId}?tone=${tone}`,
      );
      return res.data;
    },
    async editSection(
      crawlJobId: string,
      sectionId: string,
      editedContent: string | null,
    ) {
      const res = await apiClient.patch<ApiEnvelope<any>>(
        `/api/narratives/${crawlJobId}/sections/${sectionId}`,
        { editedContent },
      );
      return res.data;
    },
    async regenerateSection(
      crawlJobId: string,
      sectionType: string,
      instructions?: string,
    ) {
      const res = await apiClient.post<ApiEnvelope<any>>(
        `/api/narratives/${crawlJobId}/sections/${sectionType}/regenerate`,
        { instructions },
      );
      return res.data;
    },
    async delete(crawlJobId: string) {
      const res = await apiClient.delete<ApiEnvelope<{ deleted: boolean }>>(
        `/api/narratives/${crawlJobId}`,
      );
      return res.data;
    },
  },
};
